<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.vscode/launch.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.vscode/launch.json" />
              <option name="updatedContent" value="{&#10;    &quot;version&quot;: &quot;0.2.0&quot;,&#10;    &quot;configurations&quot;: [&#10;        {&#10;            &quot;name&quot;: &quot;Launch IO.Swagger API&quot;,&#10;            &quot;type&quot;: &quot;coreclr&quot;,&#10;            &quot;request&quot;: &quot;launch&quot;,&#10;            &quot;preLaunchTask&quot;: &quot;build&quot;,&#10;            &quot;program&quot;: &quot;${workspaceFolder}/src/IO.Swagger/bin/Debug/net8.0/IO.Swagger.dll&quot;,&#10;            &quot;args&quot;: [],&#10;            &quot;cwd&quot;: &quot;${workspaceFolder}/src/IO.Swagger&quot;,&#10;            &quot;stopAtEntry&quot;: false,&#10;            &quot;serverReadyAction&quot;: {&#10;                &quot;action&quot;: &quot;openExternally&quot;,&#10;                &quot;pattern&quot;: &quot;\\bNow listening on:\\s+(https?://\\S+)&quot;&#10;            },&#10;            &quot;env&quot;: {&#10;                &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&#10;            },&#10;            &quot;sourceFileMap&quot;: {&#10;                &quot;/Views&quot;: &quot;${workspaceFolder}/Views&quot;&#10;            }&#10;        },&#10;        {&#10;            &quot;name&quot;: &quot;Launch AppHost&quot;,&#10;            &quot;type&quot;: &quot;coreclr&quot;,&#10;            &quot;request&quot;: &quot;launch&quot;,&#10;            &quot;preLaunchTask&quot;: &quot;build&quot;,&#10;            &quot;program&quot;: &quot;${workspaceFolder}/src/IO.Swagger.AppHost/bin/Debug/net8.0/IO.Swagger.AppHost.dll&quot;,&#10;            &quot;args&quot;: [],&#10;            &quot;cwd&quot;: &quot;${workspaceFolder}/src/IO.Swagger.AppHost&quot;,&#10;            &quot;stopAtEntry&quot;: false,&#10;            &quot;serverReadyAction&quot;: {&#10;                &quot;action&quot;: &quot;openExternally&quot;,&#10;                &quot;pattern&quot;: &quot;\\bNow listening on:\\s+(https?://\\S+)&quot;&#10;            },&#10;            &quot;env&quot;: {&#10;                &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;,&#10;                &quot;DOTNET_ENVIRONMENT&quot;: &quot;Development&quot;,&#10;                &quot;DOTNET_DASHBOARD_OTLP_ENDPOINT_URL&quot;: &quot;https://localhost:18889&quot;,&#10;                &quot;DOTNET_RESOURCE_SERVICE_ENDPOINT_URL&quot;: &quot;https://localhost:17001&quot;&#10;            },&#10;            &quot;sourceFileMap&quot;: {&#10;                &quot;/Views&quot;: &quot;${workspaceFolder}/Views&quot;&#10;            }&#10;        }&#10;    ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.vscode/tasks.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.vscode/tasks.json" />
              <option name="updatedContent" value="{&#10;    &quot;version&quot;: &quot;2.0.0&quot;,&#10;    &quot;tasks&quot;: [&#10;        {&#10;            &quot;label&quot;: &quot;build&quot;,&#10;            &quot;command&quot;: &quot;dotnet&quot;,&#10;            &quot;type&quot;: &quot;process&quot;,&#10;            &quot;args&quot;: [&#10;                &quot;build&quot;,&#10;                &quot;${workspaceFolder}/IO.Swagger.sln&quot;,&#10;                &quot;/property:GenerateFullPaths=true&quot;,&#10;                &quot;/consoleloggerparameters:NoSummary&quot;&#10;            ],&#10;            &quot;problemMatcher&quot;: &quot;$msCompile&quot;&#10;        },&#10;        {&#10;            &quot;label&quot;: &quot;publish&quot;,&#10;            &quot;command&quot;: &quot;dotnet&quot;,&#10;            &quot;type&quot;: &quot;process&quot;,&#10;            &quot;args&quot;: [&#10;                &quot;publish&quot;,&#10;                &quot;${workspaceFolder}/IO.Swagger.sln&quot;,&#10;                &quot;/property:GenerateFullPaths=true&quot;,&#10;                &quot;/consoleloggerparameters:NoSummary&quot;&#10;            ],&#10;            &quot;problemMatcher&quot;: &quot;$msCompile&quot;&#10;        },&#10;        {&#10;            &quot;label&quot;: &quot;watch&quot;,&#10;            &quot;command&quot;: &quot;dotnet&quot;,&#10;            &quot;type&quot;: &quot;process&quot;,&#10;            &quot;args&quot;: [&#10;                &quot;watch&quot;,&#10;                &quot;run&quot;,&#10;                &quot;--project&quot;,&#10;                &quot;${workspaceFolder}/src/IO.Swagger/IO.Swagger.csproj&quot;&#10;            ],&#10;            &quot;problemMatcher&quot;: &quot;$msCompile&quot;&#10;        }&#10;    ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Calculator API&#10;&#10;A comprehensive .NET 9 Web API for mathematical operations with JWT authentication, Redis caching, and Kafka event streaming built with .NET Aspire.&#10;&#10;##  Project Overview&#10;&#10;This project demonstrates a modern, scalable calculator API that includes:&#10;&#10;- **JWT Bearer Authentication** - Secure API endpoints with token-based authentication&#10;- **Redis Caching** - High-performance caching for mathematical operations&#10;- **Kafka Event Streaming** - Real-time event processing for calculation workflows&#10;- **System.Text.Json** - Modern JSON serialization (migrated from Newtonsoft.Json)&#10;- **.NET Aspire** - Cloud-native orchestration and observability&#10;- **Comprehensive Testing** - Unit and integration tests with real service dependencies&#10;- **Swagger Documentation** - Interactive API documentation&#10;&#10;### Technologies Used&#10;- **.NET 9** - Latest .NET framework&#10;- **ASP.NET Core Web API** - RESTful API framework&#10;- **Redis** - In-memory caching and session storage&#10;- **Apache Kafka** - Event streaming platform&#10;- **JWT (JSON Web Tokens)** - Authentication and authorization&#10;- **xUnit** - Testing framework with comprehensive test coverage&#10;- **Docker** - Containerization support&#10;- **Mockoon** - API mocking for testing&#10;- **Serilog** - Structured logging with JSON formatting and file rotation&#10;&#10;##  API Endpoints&#10;&#10;### Authentication Endpoints&#10;- `POST /api/token/generate` - Generate JWT authentication token&#10;&#10;### Mathematical Operations&#10;- `POST /api/math` - Perform mathematical calculations&#10;  - **Operations Supported**: Addition, Subtraction, Multiplication, Division&#10;  - **Headers Required**: &#10;    - `Authorization: Bearer {token}`&#10;    - `X-ArithmeticOp-ID: {operation_id}`&#10;&#10;##  Testing&#10;&#10;The project includes comprehensive testing across multiple layers:&#10;&#10;### API Testing with Postman&#10;&#10;&lt;!-- ![Postman API Testing](images/postman.gif) --&gt;&#10;&lt;!-- Postman GIF temporarily removed due to file size - will be added back with Git LFS --&gt;&#10;&#10;The project includes a complete Postman collection for interactive API testing located in `/postman/Calculator API.postman_collection.json`.&#10;&#10;### Postman + Redis demo&#10;&#10;[![Postman + Redis Demo](https://img.youtube.com/vi/n5V-YkyUEtA/0.jpg)](https://youtu.be/n5V-YkyUEtA)&#10;&#10;### Unit Tests&#10;- **MathService Tests** - Core mathematical operation logic&#10;- **AuthenticationService Tests** - Token generation and validation&#10;- **RedisService Tests** - Direct Redis integration without mocks&#10;&#10;### Integration Tests  &#10;- **MathAPI Integration Tests** - End-to-end API testing with authentication&#10;- **Redis Integration Tests** - Real Redis caching behavior&#10;- **Authentication Integration Tests** - Complete auth workflow testing&#10;- **Comprehensive Integration Tests** - Full workflow including Kafka events&#10;- **Mockoon Integration Tests** - External service mocking and API endpoint testing&#10;&#10;### Test Features&#10;- **Real Service Dependencies** - Tests use actual Redis and application host&#10;- **Parameterized Tests** - Theory-based tests with multiple scenarios&#10;- **Error Handling** - Comprehensive error scenario coverage&#10;- **Performance Testing** - Concurrent operation testing&#10;&#10;##  Architecture Overview&#10;&#10;![Aspire Dashboard](images/AspireDashboard01.jpg)&#10;&#10;The application uses .NET Aspire for orchestration, providing:&#10;- Service discovery and configuration&#10;- Health monitoring and observability&#10;- Integrated Redis and Kafka management&#10;&#10;![Aspire Dashboard - Services](images/AspireDashboard02.jpg)&#10;&#10;##  Getting Started&#10;&#10;### Prerequisites&#10;- .NET 9 SDK&#10;- Docker Desktop&#10;&#10;### Quick Start&#10;&#10;```bash&#10;cd src/IO.Swagger.AppHost&#10;dotnet run&#10;```&#10;&#10;This will start all services including API (IO.Swagger), Redis, Redis Insight, Kafka, Kafka UI, Mockoon with the Aspire dashboard available at `https://localhost:17123`.&#10;&#10;##  Project Structure&#10;&#10;```&#10;├── src/&#10;│   ├── IO.Swagger/              # Main Web API project&#10;│   ├── IO.Swagger.AppHost/      # .NET Aspire orchestration&#10;│   ├── IO.Swagger.Models/       # Data models and DTOs&#10;│   ├── IO.Swagger.Services/     # Business logic and external services&#10;│   └── IO.Swagger.Tests/        # Comprehensive test suite&#10;├── mockoon/                     # API mocking configuration&#10;├── postman/                     # Postman collection for API testing&#10;└── images/                      # Documentation images&#10;```&#10;&#10;##  Event-Driven Architecture&#10;&#10;The API publishes Kafka events for:&#10;- **Calculation Started** - When a math operation begins&#10;- **Calculation Completed** - When a math operation finishes (includes timing, cache hits, results)&#10;&#10;Events include detailed metadata for analytics, monitoring, and audit trails.&#10;&#10;##  Process&#10;&#10;- Created API using swaggerhub with HaloAI and download as .NET Core 3/5 project&#10;- Upgrade to .NET 9 (latest versions of libraries)&#10;- Add Aspire to allow for local orchestration with ease of use for Redis, Kafka, and Mockoon docker integration, no connections strings expose in appsettings&#10;- Solutions structure refactored to separate concerns&#10;- Set JWT authentication + TokenExpirationMiddleware&#10;- Refactor to use System.Text.Json&#10;- Used GitHub Copilot (Claude Sonnet 4) to refactor code, add tests and documentation&#10;&#10;##  Configuration&#10;&#10;The application supports configuration through `appsettings.json` (IO.Swagger):&#10;&#10;```json&#10;{&#10;  &quot;Jwt&quot;: {&#10;    &quot;Key&quot;: &quot;YourSecretKey&quot;,&#10;    &quot;Issuer&quot;: &quot;Calculator.API&quot;,&#10;    &quot;Audience&quot;: &quot;Calculator.Client&quot;,&#10;    &quot;ExpiryInMinutes&quot;: 60&#10;  },&#10;  &quot;Cache&quot;: {&#10;    &quot;MathTTLSeconds&quot;: 30&#10;  },&#10;  &quot;Kafka&quot;: {&#10;    &quot;Topics&quot;: {&#10;      &quot;CalculationStarted&quot;: &quot;calculation-started&quot;,&#10;      &quot;CalculationCompleted&quot;: &quot;calculation-completed&quot;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License.&#10;" />
              <option name="updatedContent" value="# Calculator API&#10;&#10;A comprehensive .NET 9 Web API for mathematical operations with JWT authentication, Redis caching, and Kafka event streaming built with .NET Aspire.&#10;&#10;##  Project Overview&#10;&#10;This project demonstrates a modern, scalable calculator API that includes:&#10;&#10;- **JWT Bearer Authentication** - Secure API endpoints with token-based authentication&#10;- **Redis Caching** - High-performance caching for mathematical operations&#10;- **Kafka Event Streaming** - Real-time event processing for calculation workflows&#10;- **System.Text.Json** - Modern JSON serialization (migrated from Newtonsoft.Json)&#10;- **.NET Aspire** - Cloud-native orchestration and observability&#10;- **Comprehensive Testing** - Unit and integration tests with real service dependencies&#10;- **Swagger Documentation** - Interactive API documentation&#10;&#10;### Technologies Used&#10;- **.NET 9** - Latest .NET framework&#10;- **ASP.NET Core Web API** - RESTful API framework&#10;- **Redis** - In-memory caching and session storage&#10;- **Apache Kafka** - Event streaming platform&#10;- **JWT (JSON Web Tokens)** - Authentication and authorization&#10;- **xUnit** - Testing framework with comprehensive test coverage&#10;- **Docker** - Containerization support&#10;- **Mockoon** - API mocking for testing&#10;- **Serilog** - Structured logging with JSON formatting and file rotation&#10;&#10;##  API Endpoints&#10;&#10;### Authentication Endpoints&#10;- `POST /api/token/generate` - Generate JWT authentication token&#10;&#10;### Mathematical Operations&#10;- `POST /api/math` - Perform mathematical calculations&#10;  - **Operations Supported**: Addition, Subtraction, Multiplication, Division&#10;  - **Headers Required**: &#10;    - `Authorization: Bearer {token}`&#10;    - `X-ArithmeticOp-ID: {operation_id}`&#10;&#10;##  Testing&#10;&#10;The project includes comprehensive testing across multiple layers:&#10;&#10;### API Testing with Postman&#10;&#10;&lt;!-- ![Postman API Testing](images/postman.gif) --&gt;&#10;&lt;!-- Postman GIF temporarily removed due to file size - will be added back with Git LFS --&gt;&#10;&#10;The project includes a complete Postman collection for interactive API testing located in `/postman/Calculator API.postman_collection.json`.&#10;&#10;### Postman + Redis demo&#10;&#10;[![Postman + Redis Demo](https://img.youtube.com/vi/n5V-YkyUEtA/0.jpg)](https://youtu.be/n5V-YkyUEtA)&#10;&#10;### Unit Tests&#10;- **MathService Tests** - Core mathematical operation logic&#10;- **AuthenticationService Tests** - Token generation and validation&#10;- **RedisService Tests** - Direct Redis integration without mocks&#10;&#10;### Integration Tests  &#10;- **MathAPI Integration Tests** - End-to-end API testing with authentication&#10;- **Redis Integration Tests** - Real Redis caching behavior&#10;- **Authentication Integration Tests** - Complete auth workflow testing&#10;- **Comprehensive Integration Tests** - Full workflow including Kafka events&#10;- **Mockoon Integration Tests** - External service mocking and API endpoint testing&#10;&#10;### Test Features&#10;- **Real Service Dependencies** - Tests use actual Redis and application host&#10;- **Parameterized Tests** - Theory-based tests with multiple scenarios&#10;- **Error Handling** - Comprehensive error scenario coverage&#10;- **Performance Testing** - Concurrent operation testing&#10;&#10;##  Architecture Overview&#10;&#10;![Aspire Dashboard](images/AspireDashboard01.jpg)&#10;&#10;The application uses .NET Aspire for orchestration, providing:&#10;- Service discovery and configuration&#10;- Health monitoring and observability&#10;- Integrated Redis and Kafka management&#10;&#10;![Aspire Dashboard - Services](images/AspireDashboard02.jpg)&#10;&#10;##  Getting Started&#10;&#10;### Prerequisites&#10;- .NET 9 SDK&#10;- Docker Desktop&#10;&#10;### Quick Start&#10;&#10;```bash&#10;cd src/IO.Swagger.AppHost&#10;dotnet run&#10;```&#10;&#10;This will start all services including API (IO.Swagger), Redis, Redis Insight, Kafka, Kafka UI, Mockoon with the Aspire dashboard available at `https://localhost:17123`.&#10;&#10;##  Project Structure&#10;&#10;```&#10;├── src/&#10;│   ├── IO.Swagger/              # Main Web API project&#10;│   ├── IO.Swagger.AppHost/      # .NET Aspire orchestration&#10;│   ├── IO.Swagger.Models/       # Data models and DTOs&#10;│   ├── IO.Swagger.Services/     # Business logic and external services&#10;│   └── IO.Swagger.Tests/        # Comprehensive test suite&#10;├── mockoon/                     # API mocking configuration&#10;├── postman/                     # Postman collection for API testing&#10;└── images/                      # Documentation images&#10;```&#10;&#10;##  Event-Driven Architecture&#10;&#10;The API publishes Kafka events for:&#10;- **Calculation Started** - When a math operation begins&#10;- **Calculation Completed** - When a math operation finishes (includes timing, cache hits, results)&#10;&#10;Events include detailed metadata for analytics, monitoring, and audit trails.&#10;&#10;##  Robust Logging with Serilog&#10;&#10;The application implements comprehensive structured logging using Serilog with the following features:&#10;&#10;### Logging Architecture&#10;- **Structured JSON Logging** - All logs use JSON format for better parsing and analysis&#10;- **Correlation ID Tracking** - Every request gets a unique ID that follows it through all components&#10;- **Multi-Sink Output** - Logs simultaneously to console and rotating files&#10;- **Performance Monitoring** - Automatic detection of slow requests (&gt;1 second)&#10;- **Global Exception Handling** - Centralized error logging with context preservation&#10;&#10;### Middleware Components&#10;- **RequestResponseLoggingMiddleware** - Logs all HTTP requests/responses with full context&#10;- **GlobalExceptionHandlingMiddleware** - Handles unhandled exceptions with structured error responses&#10;- **PerformanceMonitoringMiddleware** - Monitors execution time and memory usage per request&#10;&#10;### Log Levels and Filtering&#10;```&#10;Information: Application events, request/response logging&#10;Warning: Slow requests, business logic warnings, non-critical errors  &#10;Error: Exceptions, failures, critical application errors&#10;Debug: Detailed performance metrics (development only)&#10;```&#10;&#10;### File Management&#10;- **Location**: `logs/io-swagger-YYYY-MM-DD.log`&#10;- **Rotation**: Daily log files with 30-day retention&#10;- **Size Limit**: 100MB per file with automatic rollover&#10;- **Format**: Compact JSON for efficient storage and parsing&#10;&#10;### Log Context Enrichment&#10;Each log entry includes:&#10;- Correlation ID for request tracing&#10;- Application name and environment&#10;- Request path, method, and user agent&#10;- Remote IP address and response times&#10;- Memory usage and performance metrics&#10;&#10;### Sample Log Output&#10;```json&#10;{&#10;  &quot;timestamp&quot;: &quot;2025-08-06T10:30:00.123Z&quot;,&#10;  &quot;level&quot;: &quot;Information&quot;, &#10;  &quot;message&quot;: &quot;Incoming request: POST /api/math&quot;,&#10;  &quot;correlationId&quot;: &quot;abc123-def456&quot;,&#10;  &quot;requestMethod&quot;: &quot;POST&quot;,&#10;  &quot;requestPath&quot;: &quot;/api/math&quot;, &#10;  &quot;applicationName&quot;: &quot;IO.Swagger.API&quot;,&#10;  &quot;environment&quot;: &quot;Development&quot;&#10;}&#10;```&#10;&#10;##  Process&#10;&#10;- Created API using swaggerhub with HaloAI and download as .NET Core 3/5 project&#10;- Upgrade to .NET 9 (latest versions of libraries)&#10;- Add Aspire to allow for local orchestration with ease of use for Redis, Kafka, and Mockoon docker integration, no connections strings expose in appsettings&#10;- Solutions structure refactored to separate concerns&#10;- Set JWT authentication + TokenExpirationMiddleware&#10;- Refactor to use System.Text.Json&#10;- Used GitHub Copilot (Claude Sonnet 4) to refactor code, add tests and documentation&#10;&#10;##  Configuration&#10;&#10;The application supports configuration through `appsettings.json` (IO.Swagger):&#10;&#10;```json&#10;{&#10;  &quot;Jwt&quot;: {&#10;    &quot;Key&quot;: &quot;YourSecretKey&quot;,&#10;    &quot;Issuer&quot;: &quot;Calculator.API&quot;,&#10;    &quot;Audience&quot;: &quot;Calculator.Client&quot;,&#10;    &quot;ExpiryInMinutes&quot;: 60&#10;  },&#10;  &quot;Cache&quot;: {&#10;    &quot;MathTTLSeconds&quot;: 30&#10;  },&#10;  &quot;Kafka&quot;: {&#10;    &quot;Topics&quot;: {&#10;      &quot;CalculationStarted&quot;: &quot;calculation-started&quot;,&#10;      &quot;CalculationCompleted&quot;: &quot;calculation-completed&quot;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.AppHost/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.AppHost/Program.cs" />
              <option name="originalContent" value="var builder = DistributedApplication.CreateBuilder(args);&#10;&#10;// Add Redis with RedisInsight&#10;var redis = builder.AddRedis(&quot;redis&quot;)&#10;                   .WithRedisInsight();&#10;&#10;// Add Kafka with UI&#10;var kafka = builder.AddKafka(&quot;kafka&quot;)&#10;                   .WithKafkaUI();&#10;&#10;// Add Mockoon CLI as Docker container&#10;var mockoon = builder.AddContainer(&quot;mockoon&quot;, &quot;mockoon/cli&quot;)&#10;                     .WithHttpEndpoint(targetPort: 3000, name: &quot;mockoon&quot;)&#10;                     .WithBindMount(&quot;../../mockoon&quot;, &quot;/data&quot;)&#10;                     .WithArgs(&quot;--data&quot;, &quot;/data/CalculatorMockoon.json&quot;, &quot;--port&quot;, &quot;3000&quot;)&#10;&#9;&#9;&#9;&#9;&#9; .WithHttpEndpoint(port: 3000, targetPort: 3000);&#10;&#10;// Add the API project with references to the services&#10;var api = builder.AddProject&lt;Projects.IO_Swagger&gt;(&quot;io-swagger&quot;)&#10;                 .WithExternalHttpEndpoints()&#10;                 .WithReference(redis)&#10;                 .WithReference(kafka);&#10;&#10;await builder.Build().RunAsync();&#10;" />
              <option name="updatedContent" value="var builder = DistributedApplication.CreateBuilder(args);&#10;&#10;// Add Redis with RedisInsight&#10;var redis = builder.AddRedis(&quot;redis&quot;)&#10;                   .WithRedisInsight();&#10;&#10;// Add Kafka with UI&#10;var kafka = builder.AddKafka(&quot;kafka&quot;)&#10;                   .WithKafkaUI();&#10;&#10;// Add Mockoon CLI as Docker container&#10;var mockoon = builder.AddContainer(&quot;mockoon&quot;, &quot;mockoon/cli&quot;)&#10;                     .WithHttpEndpoint(targetPort: 3000, name: &quot;mockoon&quot;)&#10;                     .WithBindMount(&quot;../../mockoon&quot;, &quot;/data&quot;)&#10;                     .WithArgs(&quot;--data&quot;, &quot;/data/CalculatorMockoon.json&quot;, &quot;--port&quot;, &quot;3000&quot;)&#10;&#9;&#9;&#9;&#9;&#9; .WithHttpEndpoint(port: 3000, targetPort: 3000);&#10;&#10;// Add the API project with references to the services&#10;var api = builder.AddProject&lt;Projects.IO_Swagger&gt;(&quot;io-swagger&quot;)&#10;                 .WithExternalHttpEndpoints()&#10;                 .WithReference(redis)&#10;                 .WithReference(kafka);&#10;&#10;try&#10;{&#10;    await builder.Build().RunAsync();&#10;}&#10;catch (TaskCanceledException)&#10;{&#10;    // Expected during testing scenarios when the application is shut down&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Models/BaseResponse.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Models/BaseResponse.cs" />
              <option name="originalContent" value="/*&#10; * Calculator API&#10; *&#10; * API for performing arithmetic operations&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; * &#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System;&#10;using System.Linq;&#10;using System.IO;&#10;using System.Text;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.Collections.ObjectModel;&#10;using System.ComponentModel.DataAnnotations;&#10;using System.Runtime.Serialization;&#10;using Newtonsoft.Json;&#10;&#10;namespace IO.Swagger.Models&#10;{&#10;    /// &lt;summary&gt;&#10;    /// &#10;    /// &lt;/summary&gt;&#10;    [DataContract]&#10;    public partial class BaseResponse : IEquatable&lt;BaseResponse&gt;&#10;    { &#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets Error&#10;        /// &lt;/summary&gt;&#10;&#10;        [DataMember(Name=&quot;error&quot;)]&#10;        public string Error { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;String presentation of the object&lt;/returns&gt;&#10;        public override string ToString()&#10;        {&#10;            var sb = new StringBuilder();&#10;            sb.Append(&quot;class BaseResponse {\n&quot;);&#10;            sb.Append(&quot;  Error: &quot;).Append(Error).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;}\n&quot;);&#10;            return sb.ToString();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the JSON string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;        public string ToJson()&#10;        {&#10;            return JsonConvert.SerializeObject(this, Formatting.Indented);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if objects are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public override bool Equals(object obj)&#10;        {&#10;            if (ReferenceEquals(null, obj)) return false;&#10;            if (ReferenceEquals(this, obj)) return true;&#10;            return obj.GetType() == GetType() &amp;&amp; Equals((BaseResponse)obj);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if BaseResponse instances are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;other&quot;&gt;Instance of BaseResponse to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public bool Equals(BaseResponse other)&#10;        {&#10;            if (ReferenceEquals(null, other)) return false;&#10;            if (ReferenceEquals(this, other)) return true;&#10;&#10;            return &#10;                (&#10;                    Error == other.Error ||&#10;                    Error != null &amp;&amp;&#10;                    Error.Equals(other.Error)&#10;                );&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets the hash code&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;Hash code&lt;/returns&gt;&#10;        public override int GetHashCode()&#10;        {&#10;            unchecked // Overflow is fine, just wrap&#10;            {&#10;                var hashCode = 41;&#10;                // Suitable nullity checks etc, of course :)&#10;                    if (Error != null)&#10;                    hashCode = hashCode * 59 + Error.GetHashCode();&#10;                return hashCode;&#10;            }&#10;        }&#10;&#10;        #region Operators&#10;        #pragma warning disable 1591&#10;&#10;        public static bool operator ==(BaseResponse left, BaseResponse right)&#10;        {&#10;            return Equals(left, right);&#10;        }&#10;&#10;        public static bool operator !=(BaseResponse left, BaseResponse right)&#10;        {&#10;            return !Equals(left, right);&#10;        }&#10;&#10;        #pragma warning restore 1591&#10;        #endregion Operators&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Calculator API&#10; *&#10; * API for performing arithmetic operations&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; * &#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System;&#10;using System.Linq;&#10;using System.IO;&#10;using System.Text;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.Collections.ObjectModel;&#10;using System.ComponentModel.DataAnnotations;&#10;using System.Runtime.Serialization;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Models&#10;{&#10;    /// &lt;summary&gt;&#10;    /// &#10;    /// &lt;/summary&gt;&#10;    [DataContract]&#10;    public partial class BaseResponse : IEquatable&lt;BaseResponse&gt;&#10;    { &#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets Error&#10;        /// &lt;/summary&gt;&#10;&#10;        [DataMember(Name=&quot;error&quot;)]&#10;        public string Error { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;String presentation of the object&lt;/returns&gt;&#10;        public override string ToString()&#10;        {&#10;            var sb = new StringBuilder();&#10;            sb.Append(&quot;class BaseResponse {\n&quot;);&#10;            sb.Append(&quot;  Error: &quot;).Append(Error).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;}\n&quot;);&#10;            return sb.ToString();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the JSON string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;        public string ToJson()&#10;        {&#10;            return JsonSerializer.Serialize(this, new JsonSerializerOptions { WriteIndented = true });&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if objects are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public override bool Equals(object obj)&#10;        {&#10;            if (ReferenceEquals(null, obj)) return false;&#10;            if (ReferenceEquals(this, obj)) return true;&#10;            return obj.GetType() == GetType() &amp;&amp; Equals((BaseResponse)obj);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if BaseResponse instances are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;other&quot;&gt;Instance of BaseResponse to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public bool Equals(BaseResponse other)&#10;        {&#10;            if (ReferenceEquals(null, other)) return false;&#10;            if (ReferenceEquals(this, other)) return true;&#10;&#10;            return &#10;                (&#10;                    Error == other.Error ||&#10;                    Error != null &amp;&amp;&#10;                    Error.Equals(other.Error)&#10;                );&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets the hash code&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;Hash code&lt;/returns&gt;&#10;        public override int GetHashCode()&#10;        {&#10;            unchecked // Overflow is fine, just wrap&#10;            {&#10;                var hashCode = 41;&#10;                // Suitable nullity checks etc, of course :)&#10;                    if (Error != null)&#10;                    hashCode = hashCode * 59 + Error.GetHashCode();&#10;                return hashCode;&#10;            }&#10;        }&#10;&#10;        #region Operators&#10;        #pragma warning disable 1591&#10;&#10;        public static bool operator ==(BaseResponse left, BaseResponse right)&#10;        {&#10;            return Equals(left, right);&#10;        }&#10;&#10;        public static bool operator !=(BaseResponse left, BaseResponse right)&#10;        {&#10;            return !Equals(left, right);&#10;        }&#10;&#10;        #pragma warning restore 1591&#10;        #endregion Operators&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Models/Kafka/CalculationEvents.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Models/Kafka/CalculationEvents.cs" />
              <option name="updatedContent" value="using System.Text.Json.Serialization;&#10;&#10;namespace IO.Swagger.Models.Kafka;&#10;&#10;public class CalculationStartedEvent&#10;{&#10;    [JsonPropertyName(&quot;operationId&quot;)]&#10;    public string OperationId { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;operation&quot;)]&#10;    public string Operation { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;x&quot;)]&#10;    public double X { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;y&quot;)]&#10;    public double Y { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;timestamp&quot;)]&#10;    public DateTime Timestamp { get; set; } = DateTime.UtcNow;&#10;    &#10;    [JsonPropertyName(&quot;userId&quot;)]&#10;    public string? UserId { get; set; }&#10;}&#10;&#10;public class CalculationCompletedEvent&#10;{&#10;    [JsonPropertyName(&quot;operationId&quot;)]&#10;    public string OperationId { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;operation&quot;)]&#10;    public string Operation { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;x&quot;)]&#10;    public double X { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;y&quot;)]&#10;    public double Y { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;result&quot;)]&#10;    public double? Result { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;success&quot;)]&#10;    public bool Success { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;error&quot;)]&#10;    public string? Error { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;timestamp&quot;)]&#10;    public DateTime Timestamp { get; set; } = DateTime.UtcNow;&#10;    &#10;    [JsonPropertyName(&quot;executionTimeMs&quot;)]&#10;    public long ExecutionTimeMs { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;cacheHit&quot;)]&#10;    public bool CacheHit { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;userId&quot;)]&#10;    public string? UserId { get; set; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Models/Math/MathRequest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Models/Math/MathRequest.cs" />
              <option name="originalContent" value="/*&#10; * Calculator API&#10; *&#10; * API for performing arithmetic operations&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; *&#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System.ComponentModel.DataAnnotations;&#10;using System.Runtime.Serialization;&#10;using System.Text;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Models.Math {&#10;&#9;/// &lt;summary&gt;&#10;&#9;///  MathRequest class represents a request for performing a mathematical operation.&#10;&#9;///  It contains the operands (X and Y) and the operation type (Addition, Subtraction, Multiplication, or Division).&#10;&#9;///  The class implements IEquatable for equality comparison and provides methods for string representation and JSON serialization.&#10;&#9;///  The properties X and Y are required and must be decimal values, while the Operation property is of type MathOperationType,&#10;&#9;/// &lt;/summary&gt;&#10;&#9;[DataContract]&#10;&#9;public partial class MathRequest : IEquatable&lt;MathRequest&gt; {&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Gets or Sets X&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;[Required] [DataMember(Name = &quot;x&quot;)] public decimal? X { get; set; }&#10;&#9;&#9;/// Gets or Sets Y&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;[Required] [DataMember(Name = &quot;y&quot;)] public decimal? Y { get; set; }&#10;&#10;&#9;&#9;[Required] [DataMember(Name = &quot;y&quot;)] public decimal? Y { get; set; }&#10;&#9;&#9;[Required] [DataMember(Name = &quot;operation&quot;)] public MathOperationType Operation { get; set; }&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns the string presentation of the object&#10;&#9;&#9;[Required] [DataMember(Name = &quot;operation&quot;)] public MathOperationType Operation { get; set; }&#10;&#9;&#9;&#9;var sb = new StringBuilder();&#10;&#9;&#9;&#9;sb.Append(&quot;class MathRequest {\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;  X: &quot;).Append(X).Append(&quot;\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;  Y: &quot;).Append(Y).Append(&quot;\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;  Operation: &quot;).Append(Operation).Append(&quot;\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;}\n&quot;);&#10;&#9;&#9;&#9;return sb.ToString();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns the JSON string presentation of the object&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;&#9;&#9;public string ToJson() {&#10;&#9;&#9;&#9;return JsonSerializer.Serialize(this,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;new JsonSerializerOptions {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;WriteIndented = true&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;});&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns true if objects are equal&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;&#9;&#9;/// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;&#9;&#9;public override bool Equals(object obj) {&#10;&#9;&#9;&#9;if (ReferenceEquals(null,obj))&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;if (ReferenceEquals(this,obj))&#10;&#9;&#9;&#9;&#9;return true;&#10;&#9;&#9;&#9;return obj.GetType() == GetType() &amp;&amp; Equals((MathRequest)obj);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns true if MathRequest instances are equal&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;other&quot;&gt;Instance of MathRequest to be compared&lt;/param&gt;&#10;&#9;&#9;/// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;&#9;&#9;public bool Equals(MathRequest other) {&#10;&#9;&#9;&#9;if (ReferenceEquals(null,other))&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;if (ReferenceEquals(this,other))&#10;&#9;&#9;&#9;&#9;return true;&#10;&#9;&#9;&#9;return (X == other.X || X != null &amp;&amp; X.Equals(other.X)) &amp;&amp; (Y == other.Y || Y != null &amp;&amp; Y.Equals(other.Y)) &amp;&amp; (Operation == other.Operation || Operation != null &amp;&amp; Operation.Equals(other.Operation));&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Gets the hash code&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;returns&gt;Hash code&lt;/returns&gt;&#10;&#9;&#9;public override int GetHashCode() {&#10;&#9;&#9;&#9;unchecked // Overflow is fine, just wrap&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;var hashCode = 41;&#10;&#9;&#9;&#9;&#9;// Suitable nullity checks etc, of course :)&#10;&#9;&#9;&#9;&#9;if (X != null)&#10;&#9;&#9;&#9;&#9;&#9;hashCode = hashCode * 59 + X.GetHashCode();&#10;&#9;&#9;&#9;&#9;if (Y != null)&#10;&#9;&#9;&#9;&#9;&#9;hashCode = hashCode * 59 + Y.GetHashCode();&#10;&#9;&#9;&#9;&#9;if (Operation != null)&#10;&#9;&#9;&#9;&#9;&#9;hashCode = hashCode * 59 + Operation.GetHashCode();&#10;&#9;&#9;&#9;&#9;return hashCode;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;#region Operators&#10;#pragma warning disable 1591&#10;&#10;&#9;&#9;public static bool operator==(MathRequest left,MathRequest right) {&#10;&#9;&#9;&#9;return Equals(left,right);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public static bool operator!=(MathRequest left,MathRequest right) {&#10;&#9;&#9;&#9;return !Equals(left,right);&#10;&#9;&#9;}&#10;&#10;#pragma warning restore 1591&#10;#endregion Operators&#10;&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Calculator API&#10; *&#10; * API for performing arithmetic operations&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; *&#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System.ComponentModel.DataAnnotations;&#10;using System.Runtime.Serialization;&#10;using System.Text;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Models.Math {&#10;&#9;/// &lt;summary&gt;&#10;&#9;///  MathRequest class represents a request for performing a mathematical operation.&#10;&#9;///  It contains the operands (X and Y) and the operation type (Addition, Subtraction, Multiplication, or Division).&#10;&#9;///  The class implements IEquatable for equality comparison and provides methods for string representation and JSON serialization.&#10;&#9;///  The properties X and Y are required and must be decimal values, while the Operation property is of type MathOperationType,&#10;&#9;/// &lt;/summary&gt;&#10;&#9;[DataContract]&#10;&#9;public partial class MathRequest : IEquatable&lt;MathRequest&gt; {&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Gets or Sets X&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;[Required]&#10;&#9;&#9;[DataMember(Name=&quot;x&quot;)]&#10;&#9;&#9;public double? X { get; set; }&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Gets or Sets Y&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;[Required]&#10;&#9;&#9;[DataMember(Name=&quot;y&quot;)]&#10;&#9;&#9;public double? Y { get; set; }&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Gets or Sets Operation&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;[Required]&#10;&#9;&#9;[DataMember(Name=&quot;operation&quot;)]&#10;&#9;&#9;public MathOperationType? Operation { get; set; }&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns the string presentation of the object&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;returns&gt;String presentation of the object&lt;/returns&gt;&#10;&#9;&#9;public override string ToString() {&#10;&#9;&#9;&#9;var sb = new StringBuilder();&#10;&#9;&#9;&#9;sb.Append(&quot;class MathRequest {\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;  X: &quot;).Append(X).Append(&quot;\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;  Y: &quot;).Append(Y).Append(&quot;\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;  Operation: &quot;).Append(Operation).Append(&quot;\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;}\n&quot;);&#10;&#9;&#9;&#9;return sb.ToString();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns the JSON string presentation of the object&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;&#9;&#9;public string ToJson() {&#10;&#9;&#9;&#9;return JsonSerializer.Serialize(this,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;new JsonSerializerOptions {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;WriteIndented = true&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;});&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns true if objects are equal&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;&#9;&#9;/// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;&#9;&#9;public override bool Equals(object obj) {&#10;&#9;&#9;&#9;if (ReferenceEquals(null,obj))&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;if (ReferenceEquals(this,obj))&#10;&#9;&#9;&#9;&#9;return true;&#10;&#9;&#9;&#9;return obj.GetType() == GetType() &amp;&amp; Equals((MathRequest)obj);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns true if MathRequest instances are equal&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;other&quot;&gt;Instance of MathRequest to be compared&lt;/param&gt;&#10;&#9;&#9;/// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;&#9;&#9;public bool Equals(MathRequest other) {&#10;&#9;&#9;&#9;if (ReferenceEquals(null,other))&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;if (ReferenceEquals(this,other))&#10;&#9;&#9;&#9;&#9;return true;&#10;&#9;&#9;&#9;return (X == other.X || X != null &amp;&amp; X.Equals(other.X)) &amp;&amp; (Y == other.Y || Y != null &amp;&amp; Y.Equals(other.Y)) &amp;&amp; (Operation == other.Operation || Operation != null &amp;&amp; Operation.Equals(other.Operation));&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Gets the hash code&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;returns&gt;Hash code&lt;/returns&gt;&#10;&#9;&#9;public override int GetHashCode() {&#10;&#9;&#9;&#9;unchecked // Overflow is fine, just wrap&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;var hashCode = 41;&#10;&#9;&#9;&#9;&#9;// Suitable nullity checks etc, of course :)&#10;&#9;&#9;&#9;&#9;if (X != null)&#10;&#9;&#9;&#9;&#9;&#9;hashCode = hashCode * 59 + X.GetHashCode();&#10;&#9;&#9;&#9;&#9;if (Y != null)&#10;&#9;&#9;&#9;&#9;&#9;hashCode = hashCode * 59 + Y.GetHashCode();&#10;&#9;&#9;&#9;&#9;if (Operation != null)&#10;&#9;&#9;&#9;&#9;&#9;hashCode = hashCode * 59 + Operation.GetHashCode();&#10;&#9;&#9;&#9;&#9;return hashCode;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;#region Operators&#10;#pragma warning disable 1591&#10;&#10;&#9;&#9;public static bool operator==(MathRequest left,MathRequest right) {&#10;&#9;&#9;&#9;return Equals(left,right);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public static bool operator!=(MathRequest left,MathRequest right) {&#10;&#9;&#9;&#9;return !Equals(left,right);&#10;&#9;&#9;}&#10;&#10;#pragma warning restore 1591&#10;#endregion Operators&#10;&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Models/Math/MathResponse.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Models/Math/MathResponse.cs" />
              <option name="originalContent" value="/*&#10; * Calculator API&#10; *&#10; * API for performing arithmetic operations&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; *&#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System.Runtime.Serialization;&#10;&#10;&#9;public partial class MathResponse : IEquatable&lt;MathResponse&gt; {&#10;&#9;&#9;/// &lt;summary&gt;&#10;namespace IO.Swagger.Models.Math {&#10;&#9;/// &lt;summary&gt;&#10;&#9;///  MathResponse class represents the response for a mathematical operation.&#10;&#9;/// &lt;/summary&gt;&#10;&#9;[DataContract]&#10;&#9;public partial class MathResponse : IEquatable&lt;MathResponse&gt; {&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Gets or Sets Result&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#10;&#9;&#9;[DataMember(Name = &quot;result&quot;)] public decimal? Result { get; set; }&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns the string presentation of the object&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;returns&gt;String presentation of the object&lt;/returns&gt;&#10;&#9;&#9;public override string ToString() {&#10;&#9;&#9;&#9;var sb = new StringBuilder();&#10;&#9;&#9;&#9;sb.Append(&quot;class MathResponse {\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;  Result: &quot;).Append(Result).Append(&quot;\n&quot;);&#10;&#9;&#9;&#9;sb.Append(&quot;}\n&quot;);&#10;&#9;&#9;&#9;return sb.ToString();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns the JSON string presentation of the object&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;&#9;&#9;public string ToJson() {&#10;&#9;&#9;&#9;return JsonSerializer.Serialize(this,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;new JsonSerializerOptions {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;WriteIndented = true&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;});&#10;&#9;&#9;}&#10;&#9;&#9;&#9;if (ReferenceEquals(this,other))&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns true if objects are equal&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;&#9;&#9;/// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;&#9;&#9;public override bool Equals(object obj) {&#10;&#9;&#9;&#9;if (ReferenceEquals(null,obj))&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;if (ReferenceEquals(this,obj))&#10;&#9;&#9;&#9;&#9;return true;&#10;&#9;&#9;&#9;return obj.GetType() == GetType() &amp;&amp; Equals((MathResponse)obj);&#10;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;var hashCode = 41;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Returns true if MathResponse instances are equal&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;/// &lt;param name=&quot;other&quot;&gt;Instance of MathResponse to be compared&lt;/param&gt;&#10;&#9;&#9;/// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;&#9;&#9;public bool Equals(MathResponse other) {&#10;&#9;&#9;&#9;if (ReferenceEquals(null,other))&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;if (ReferenceEquals(this,other))&#10;&#9;&#9;&#9;&#9;return true;&#10;&#9;&#9;&#9;return (Result == other.Result || Result != null &amp;&amp; Result.Equals(other.Result));&#10;&#9;&#9;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Calculator API&#10; *&#10; * API for performing arithmetic operations&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; *&#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System;&#10;using System.Linq;&#10;using System.IO;&#10;using System.Text;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.Collections.ObjectModel;&#10;using System.ComponentModel.DataAnnotations;&#10;using System.Runtime.Serialization;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Models&#10;{&#10;    /// &lt;summary&gt;&#10;    /// &#10;    /// &lt;/summary&gt;&#10;    [DataContract]&#10;    public partial class MathResponse : IEquatable&lt;MathResponse&gt;&#10;    { &#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets Result&#10;        /// &lt;/summary&gt;&#10;        [DataMember(Name=&quot;result&quot;)]&#10;        public double? Result { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets Error&#10;        /// &lt;/summary&gt;&#10;        [DataMember(Name=&quot;error&quot;)]&#10;        public string Error { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets Success&#10;        /// &lt;/summary&gt;&#10;        [DataMember(Name=&quot;success&quot;)]&#10;        public bool? Success { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;String presentation of the object&lt;/returns&gt;&#10;        public override string ToString()&#10;        {&#10;            var sb = new StringBuilder();&#10;            sb.Append(&quot;class MathResponse {\n&quot;);&#10;            sb.Append(&quot;  Result: &quot;).Append(Result).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;  Error: &quot;).Append(Error).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;  Success: &quot;).Append(Success).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;}\n&quot;);&#10;            return sb.ToString();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the JSON string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;        public string ToJson()&#10;        {&#10;            return JsonSerializer.Serialize(this, new JsonSerializerOptions { WriteIndented = true });&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if objects are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public override bool Equals(object obj)&#10;        {&#10;            if (ReferenceEquals(null, obj)) return false;&#10;            if (ReferenceEquals(this, obj)) return true;&#10;            return obj.GetType() == GetType() &amp;&amp; Equals((MathResponse)obj);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if MathResponse instances are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;other&quot;&gt;Instance of MathResponse to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public bool Equals(MathResponse other)&#10;        {&#10;            if (ReferenceEquals(null, other)) return false;&#10;            if (ReferenceEquals(this, other)) return true;&#10;&#10;            return &#10;                (&#10;                    Result == other.Result ||&#10;                    Result != null &amp;&amp;&#10;                    Result.Equals(other.Result)&#10;                ) &amp;&amp; &#10;                (&#10;                    Error == other.Error ||&#10;                    Error != null &amp;&amp;&#10;                    Error.Equals(other.Error)&#10;                ) &amp;&amp; &#10;                (&#10;                    Success == other.Success ||&#10;                    Success != null &amp;&amp;&#10;                    Success.Equals(other.Success)&#10;                );&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets the hash code&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;Hash code&lt;/returns&gt;&#10;        public override int GetHashCode()&#10;        {&#10;            unchecked // Overflow is fine, just wrap&#10;            {&#10;                var hashCode = 41;&#10;                // Suitable nullity checks etc, of course :)&#10;                    if (Result != null)&#10;                    hashCode = hashCode * 59 + Result.GetHashCode();&#10;                    if (Error != null)&#10;                    hashCode = hashCode * 59 + Error.GetHashCode();&#10;                    if (Success != null)&#10;                    hashCode = hashCode * 59 + Success.GetHashCode();&#10;                return hashCode;&#10;            }&#10;        }&#10;&#10;        #region Operators&#10;        #pragma warning disable 1591&#10;&#10;        public static bool operator ==(MathResponse left, MathResponse right)&#10;        {&#10;            return Equals(left, right);&#10;        }&#10;&#10;        public static bool operator !=(MathResponse left, MathResponse right)&#10;        {&#10;            return !Equals(left, right);&#10;        }&#10;&#10;        #pragma warning restore 1591&#10;        #endregion Operators&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Services/Kafka/KafkaConsumerService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Services/Kafka/KafkaConsumerService.cs" />
              <option name="originalContent" value="using Confluent.Kafka;&#10;using IO.Swagger.Models.Kafka;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Services.Kafka;&#10;&#10;public class KafkaConsumerService : BackgroundService {&#10;&#9;private readonly IConsumer&lt;string,string&gt; _consumer;&#10;&#9;private readonly ILogger&lt;KafkaConsumerService&gt; _logger;&#10;&#9;private readonly IServiceProvider _serviceProvider;&#10;&#9;private readonly string[] _topics;&#10;&#9;private readonly string _bootstrapServers;&#10;&#10;&#9;public KafkaConsumerService(IConfiguration configuration,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ILogger&lt;KafkaConsumerService&gt; logger,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;IServiceProvider serviceProvider) {&#10;&#9;&#9;_logger = logger;&#10;&#9;&#9;_serviceProvider = serviceProvider;&#10;&#9;&#9;var calculationStartedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationStarted&quot;) ?? &quot;calculation-started&quot;;&#10;&#9;&#9;var calculationCompletedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationCompleted&quot;) ?? &quot;calculation-completed&quot;;&#10;&#9;&#9;_topics = [calculationStartedTopic,calculationCompletedTopic];&#10;&#9;&#9;_bootstrapServers = configuration.GetConnectionString(&quot;kafka&quot;) ?? &quot;localhost:9092&quot;;&#10;&#9;&#9;var config = new ConsumerConfig {&#10;&#9;&#9;&#9;BootstrapServers = _bootstrapServers,&#10;&#9;&#9;&#9;GroupId = &quot;io-swagger-consumer-group&quot;,&#10;&#9;&#9;&#9;ClientId = &quot;io-swagger-consumer&quot;,&#10;&#9;&#9;&#9;AutoOffsetReset = AutoOffsetReset.Earliest,&#10;&#9;&#9;&#9;EnableAutoCommit = false,&#10;&#9;&#9;&#9;EnableAutoOffsetStore = false,&#10;&#9;&#9;&#9;SessionTimeoutMs = 30000,&#10;&#9;&#9;&#9;HeartbeatIntervalMs = 10000,&#10;&#9;&#9;&#9;MaxPollIntervalMs = 300000,&#10;&#9;&#9;&#9;FetchMinBytes = 1,&#10;&#9;&#9;};&#10;&#9;&#9;_consumer = new ConsumerBuilder&lt;string,string&gt;(config).SetErrorHandler((_,e) =&gt; _logger.LogError(&quot;Kafka consumer error: {Error}&quot;,e))&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetLogHandler((_,log) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  if (log.Level &lt;= SyslogLevel.Warning)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogWarning(&quot;Kafka consumer log: {Message}&quot;,log.Message);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetPartitionsAssignedHandler((c,partitions) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogInformation(&quot;Kafka consumer assigned partitions: {Partitions}&quot;,string.Join(&quot;, &quot;,partitions.Select(p =&gt; $&quot;{p.Topic}[{p.Partition}]&quot;)));&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetPartitionsRevokedHandler((c,partitions) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogInformation(&quot;Kafka consumer revoked partitions: {Partitions}&quot;,string.Join(&quot;, &quot;,partitions.Select(p =&gt; $&quot;{p.Topic}[{p.Partition}]&quot;)));&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .Build();&#10;&#9;}&#10;&#10;&#9;protected override async Task ExecuteAsync(CancellationToken stoppingToken) {&#10;&#9;&#9;// Wait for Kafka broker to be ready before subscribing&#10;&#9;&#9;await WaitForKafkaBrokerAsync(stoppingToken);&#10;&#9;&#9;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;_consumer.Subscribe(_topics);&#10;&#9;&#9;&#9;_logger.LogInformation(&quot;Kafka consumer started. Subscribed to topics: {Topics}&quot;,string.Join(&quot;, &quot;,_topics));&#10;&#9;&#9;&#9;while (!stoppingToken.IsCancellationRequested) {&#10;&#9;&#9;&#9;&#9;try {&#10;&#9;&#9;&#9;&#9;&#9;var consumeResult = _consumer.Consume(TimeSpan.FromSeconds(1));&#10;&#9;&#9;&#9;&#9;&#9;if (consumeResult?.Message != null) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;await ProcessMessageAsync(consumeResult,stoppingToken);&#10;&#9;&#9;&#9;&#9;&#9;&#9;_consumer.Commit(consumeResult);&#10;&#9;&#9;&#9;&#9;&#9;&#9;_consumer.StoreOffset(consumeResult);&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (ConsumeException ex) when (ex.Error.Code == ErrorCode.UnknownTopicOrPart) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogWarning(&quot;Topics not yet available, waiting 5 seconds before retry: {Error}&quot;, ex.Error.Reason);&#10;&#9;&#9;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (ConsumeException ex) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogError(ex,&quot;Kafka consume error: {Error}&quot;,ex.Error.Reason);&#10;&#9;&#9;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (OperationCanceledException) {&#10;&#9;&#9;&#9;&#9;&#9;// Expected when cancellation is requested&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogError(ex,&quot;Unexpected error in Kafka consumer&quot;);&#10;&#9;&#9;&#9;&#9;&#9;// Don't break the loop for unexpected errors, just log and continue&#10;&#9;&#9;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(5),stoppingToken);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger?.LogCritical(ex,&quot;Fatal error in Kafka consumer service&quot;);&#10;&#9;&#9;}&#10;&#9;&#9;finally {&#10;&#9;&#9;&#9;try {&#10;&#9;&#9;&#9;&#9;_consumer?.Close();&#10;&#9;&#9;&#9;&#9;_consumer?.Dispose();&#10;&#9;&#9;&#9;&#9;_logger?.LogInformation(&quot;Kafka consumer service stopped&quot;);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;&#9;_logger?.LogError(ex,&quot;Error disposing Kafka consumer&quot;);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private async Task WaitForKafkaBrokerAsync(CancellationToken cancellationToken) {&#10;&#9;&#9;var retryCount = 0;&#10;&#9;&#9;const int maxRetries = 30; // 30 seconds max wait&#10;&#9;&#9;&#10;&#9;&#9;while (retryCount &lt; maxRetries &amp;&amp; !cancellationToken.IsCancellationRequested) {&#10;&#9;&#9;&#9;try {&#10;&#9;&#9;&#9;&#9;using var adminClient = new AdminClientBuilder(new AdminClientConfig {&#10;&#9;&#9;&#9;&#9;&#9;BootstrapServers = _bootstrapServers&#10;&#9;&#9;&#9;&#9;}).Build();&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;var metadata = adminClient.GetMetadata(TimeSpan.FromSeconds(5));&#10;&#9;&#9;&#9;&#9;if (metadata.Brokers.Count &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogInformation(&quot;Kafka broker is ready. Found {BrokerCount} broker(s)&quot;, metadata.Brokers.Count);&#10;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;&#9;_logger.LogDebug(&quot;Waiting for Kafka broker to be ready (attempt {Attempt}/{MaxAttempts}): {Error}&quot;, &#10;&#9;&#9;&#9;&#9;&#9;retryCount + 1, maxRetries, ex.Message);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;retryCount++;&#10;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);&#10;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;_logger.LogWarning(&quot;Kafka broker not ready after {MaxRetries} seconds, continuing anyway&quot;, maxRetries);&#10;&#9;}&#10;&#10;&#9;private async Task ProcessMessageAsync(ConsumeResult&lt;string,string&gt; result,CancellationToken cancellationToken) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var eventType = GetEventTypeFromHeaders(result.Message.Headers);&#10;&#9;&#9;&#9;_logger.LogDebug(&quot;Processing Kafka message. Topic: {Topic}, Key: {Key}, EventType: {EventType}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Message.Key,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; eventType);&#10;&#9;&#9;&#9;switch (eventType) {&#10;&#9;&#9;&#9;&#9;case &quot;CalculationStarted&quot;:&#10;&#9;&#9;&#9;&#9;&#9;await ProcessCalculationStartedEvent(result.Message.Value,cancellationToken);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;case &quot;CalculationCompleted&quot;:&#10;&#9;&#9;&#9;&#9;&#9;await ProcessCalculationCompletedEvent(result.Message.Value,cancellationToken);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;default:&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogWarning(&quot;Unknown event type: {EventType} for message key: {Key}&quot;,eventType,result.Message.Key);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;_logger.LogDebug(&quot;Successfully processed Kafka message. Topic: {Topic}, Key: {Key}, Offset: {Offset}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Message.Key,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Offset);&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &quot;Error processing Kafka message. Topic: {Topic}, Key: {Key}, Offset: {Offset}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Message?.Key,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Offset);&#10;&#9;&#9;&#9;throw; // Re-throw to prevent commit&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private async Task ProcessCalculationStartedEvent(string messageValue,CancellationToken cancellationToken) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var calculationEvent = JsonSerializer.Deserialize&lt;CalculationStartedEvent&gt;(messageValue);&#10;&#9;&#9;&#9;if (calculationEvent == null)&#10;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;using var scope = _serviceProvider.CreateScope();&#10;&#9;&#9;&#9;var logger = scope.ServiceProvider.GetRequiredService&lt;ILogger&lt;KafkaConsumerService&gt;&gt;();&#10;&#9;&#9;&#9;logger.LogInformation(&quot;Processing calculation started event for operation {OperationId}: {Operation}({X}, {Y})&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Operation,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.X,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Y);&#10;&#10;&#9;&#9;&#9;// Here you could add business logic like:&#10;&#9;&#9;&#9;// - Updating operation status in database&#10;&#9;&#9;&#9;// - Sending notifications&#10;&#9;&#9;&#9;// - Triggering other workflows&#10;&#9;&#9;&#9;// - Metrics collection&#10;&#9;&#9;&#9;await Task.CompletedTask; // Placeholder for actual processing&#10;&#9;&#9;}&#10;&#9;&#9;catch (JsonException ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to deserialize CalculationStartedEvent: {MessageValue}&quot;,messageValue);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private async Task ProcessCalculationCompletedEvent(string messageValue,CancellationToken cancellationToken) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var calculationEvent = JsonSerializer.Deserialize&lt;CalculationCompletedEvent&gt;(messageValue);&#10;&#9;&#9;&#9;if (calculationEvent == null)&#10;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;using var scope = _serviceProvider.CreateScope();&#10;&#9;&#9;&#9;var logger = scope.ServiceProvider.GetRequiredService&lt;ILogger&lt;KafkaConsumerService&gt;&gt;();&#10;&#9;&#9;&#9;logger.LogInformation(&quot;Processing calculation completed event for operation {OperationId}: Success={Success}, Result={Result}, ExecutionTime={ExecutionTime}ms, CacheHit={CacheHit}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Success,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Result,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.ExecutionTimeMs,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.CacheHit);&#10;&#10;&#9;&#9;&#9;// Here you could add business logic like:&#10;&#9;&#9;&#9;// - Updating final operation status in database&#10;&#9;&#9;&#9;// - Sending completion notifications&#10;&#9;&#9;&#9;// - Updating analytics/metrics&#10;&#9;&#9;&#9;// - Triggering downstream processes&#10;&#9;&#9;&#9;// - Audit logging&#10;&#9;&#9;&#9;await Task.CompletedTask; // Placeholder for actual processing&#10;&#9;&#9;}&#10;&#9;&#9;catch (JsonException ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to deserialize CalculationCompletedEvent: {MessageValue}&quot;,messageValue);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private static string GetEventTypeFromHeaders(Headers? headers) {&#10;&#9;&#9;if (headers == null)&#10;&#9;&#9;&#9;return &quot;Unknown&quot;;&#10;&#9;&#9;var eventTypeHeader = headers.FirstOrDefault(h =&gt; h.Key == &quot;eventType&quot;);&#10;&#9;&#9;return eventTypeHeader != null ? System.Text.Encoding.UTF8.GetString(eventTypeHeader.GetValueBytes()) : &quot;Unknown&quot;;&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="using Confluent.Kafka;&#10;using IO.Swagger.Models.Kafka;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Services.Kafka;&#10;&#10;public class KafkaConsumerService : BackgroundService {&#10;&#9;private readonly IConsumer&lt;string,string&gt; _consumer;&#10;&#9;private readonly ILogger&lt;KafkaConsumerService&gt; _logger;&#10;&#9;private readonly IServiceProvider _serviceProvider;&#10;&#9;private readonly string[] _topics;&#10;&#9;private readonly string _bootstrapServers;&#10;&#10;&#9;public KafkaConsumerService(IConfiguration configuration,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ILogger&lt;KafkaConsumerService&gt; logger,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;IServiceProvider serviceProvider) {&#10;&#9;&#9;_logger = logger;&#10;&#9;&#9;_serviceProvider = serviceProvider;&#10;&#9;&#9;var calculationStartedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationStarted&quot;) ?? &quot;calculation-started&quot;;&#10;&#9;&#9;var calculationCompletedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationCompleted&quot;) ?? &quot;calculation-completed&quot;;&#10;&#9;&#9;_topics = [calculationStartedTopic,calculationCompletedTopic];&#10;&#9;&#9;_bootstrapServers = configuration.GetConnectionString(&quot;kafka&quot;) ?? &quot;localhost:9092&quot;;&#10;&#9;&#9;var config = new ConsumerConfig {&#10;&#9;&#9;&#9;BootstrapServers = _bootstrapServers,&#10;&#9;&#9;&#9;GroupId = &quot;io-swagger-consumer-group&quot;,&#10;&#9;&#9;&#9;ClientId = &quot;io-swagger-consumer&quot;,&#10;&#9;&#9;&#9;AutoOffsetReset = AutoOffsetReset.Earliest,&#10;&#9;&#9;&#9;EnableAutoCommit = false,&#10;&#9;&#9;&#9;EnableAutoOffsetStore = false,&#10;&#9;&#9;&#9;SessionTimeoutMs = 30000,&#10;&#9;&#9;&#9;HeartbeatIntervalMs = 10000,&#10;&#9;&#9;&#9;MaxPollIntervalMs = 300000,&#10;&#9;&#9;&#9;FetchMinBytes = 1,&#10;&#9;&#9;};&#10;&#9;&#9;_consumer = new ConsumerBuilder&lt;string,string&gt;(config).SetErrorHandler((_,e) =&gt; _logger.LogError(&quot;Kafka consumer error: {Error}&quot;,e))&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetLogHandler((_,log) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  if (log.Level &lt;= SyslogLevel.Warning)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogWarning(&quot;Kafka consumer log: {Message}&quot;,log.Message);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetPartitionsAssignedHandler((c,partitions) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogInformation(&quot;Kafka consumer assigned partitions: {Partitions}&quot;,string.Join(&quot;, &quot;,partitions.Select(p =&gt; $&quot;{p.Topic}[{p.Partition}]&quot;)));&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetPartitionsRevokedHandler((c,partitions) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogInformation(&quot;Kafka consumer revoked partitions: {Partitions}&quot;,string.Join(&quot;, &quot;,partitions.Select(p =&gt; $&quot;{p.Topic}[{p.Partition}]&quot;)));&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .Build();&#10;&#9;}&#10;&#10;&#9;protected override async Task ExecuteAsync(CancellationToken stoppingToken) {&#10;&#9;&#9;_logger.LogInformation(&quot;Starting Kafka consumer service...&quot;);&#10;&#9;&#9;&#10;&#9;&#9;// Wait for Kafka broker to be ready before doing anything&#10;&#9;&#9;await WaitForKafkaBrokerAsync(stoppingToken);&#10;&#9;&#9;&#10;&#9;&#9;if (stoppingToken.IsCancellationRequested) {&#10;&#9;&#9;&#9;_logger.LogInformation(&quot;Kafka consumer service cancelled during startup&quot;);&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;_consumer.Subscribe(_topics);&#10;&#9;&#9;&#9;_logger.LogInformation(&quot;Kafka consumer started. Subscribed to topics: {Topics}&quot;,string.Join(&quot;, &quot;,_topics));&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;while (!stoppingToken.IsCancellationRequested) {&#10;&#9;&#9;&#9;&#9;try {&#10;&#9;&#9;&#9;&#9;&#9;var consumeResult = _consumer.Consume(TimeSpan.FromSeconds(1));&#10;&#9;&#9;&#9;&#9;&#9;if (consumeResult?.Message != null) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;await ProcessMessageAsync(consumeResult,stoppingToken);&#10;&#9;&#9;&#9;&#9;&#9;&#9;_consumer.Commit(consumeResult);&#10;&#9;&#9;&#9;&#9;&#9;&#9;_consumer.StoreOffset(consumeResult);&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (ConsumeException ex) when (ex.Error.Code == ErrorCode.UnknownTopicOrPart) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogInformation(&quot;Topics not yet available, waiting for producer to create them: {Error}&quot;, ex.Error.Reason);&#10;&#9;&#9;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(10), stoppingToken);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (ConsumeException ex) when (ex.Error.Code == ErrorCode.BrokerNotAvailable || &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   ex.Error.Code == ErrorCode.NetworkException ||&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   ex.Error.Code == ErrorCode.AllBrokersDown) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogWarning(&quot;Kafka broker connectivity issue, retrying in 10 seconds: {Error}&quot;, ex.Error.Reason);&#10;&#9;&#9;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(10), stoppingToken);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (ConsumeException ex) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogError(ex,&quot;Kafka consume error: {Error}&quot;,ex.Error.Reason);&#10;&#9;&#9;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (OperationCanceledException) {&#10;&#9;&#9;&#9;&#9;&#9;// Expected when cancellation is requested&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogError(ex,&quot;Unexpected error in Kafka consumer&quot;);&#10;&#9;&#9;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(5),stoppingToken);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger?.LogCritical(ex,&quot;Fatal error in Kafka consumer service&quot;);&#10;&#9;&#9;}&#10;&#9;&#9;finally {&#10;&#9;&#9;&#9;try {&#10;&#9;&#9;&#9;&#9;_consumer?.Close();&#10;&#9;&#9;&#9;&#9;_consumer?.Dispose();&#10;&#9;&#9;&#9;&#9;_logger?.LogInformation(&quot;Kafka consumer service stopped&quot;);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;&#9;_logger?.LogError(ex,&quot;Error disposing Kafka consumer&quot;);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private async Task WaitForKafkaBrokerAsync(CancellationToken cancellationToken) {&#10;&#9;&#9;var retryCount = 0;&#10;&#9;&#9;const int maxRetries = 30; // 30 seconds max wait&#10;&#9;&#9;&#10;&#9;&#9;while (retryCount &lt; maxRetries &amp;&amp; !cancellationToken.IsCancellationRequested) {&#10;&#9;&#9;&#9;try {&#10;&#9;&#9;&#9;&#9;using var adminClient = new AdminClientBuilder(new AdminClientConfig {&#10;&#9;&#9;&#9;&#9;&#9;BootstrapServers = _bootstrapServers&#10;&#9;&#9;&#9;&#9;}).Build();&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;var metadata = adminClient.GetMetadata(TimeSpan.FromSeconds(5));&#10;&#9;&#9;&#9;&#9;if (metadata.Brokers.Count &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogInformation(&quot;Kafka broker is ready. Found {BrokerCount} broker(s)&quot;, metadata.Brokers.Count);&#10;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;&#9;_logger.LogDebug(&quot;Waiting for Kafka broker to be ready (attempt {Attempt}/{MaxAttempts}): {Error}&quot;, &#10;&#9;&#9;&#9;&#9;&#9;retryCount + 1, maxRetries, ex.Message);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;retryCount++;&#10;&#9;&#9;&#9;await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);&#10;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;_logger.LogWarning(&quot;Kafka broker not ready after {MaxRetries} seconds, continuing anyway&quot;, maxRetries);&#10;&#9;}&#10;&#10;&#9;private async Task ProcessMessageAsync(ConsumeResult&lt;string,string&gt; result,CancellationToken cancellationToken) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var eventType = GetEventTypeFromHeaders(result.Message.Headers);&#10;&#9;&#9;&#9;_logger.LogDebug(&quot;Processing Kafka message. Topic: {Topic}, Key: {Key}, EventType: {EventType}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Message.Key,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; eventType);&#10;&#9;&#9;&#9;switch (eventType) {&#10;&#9;&#9;&#9;&#9;case &quot;CalculationStarted&quot;:&#10;&#9;&#9;&#9;&#9;&#9;await ProcessCalculationStartedEvent(result.Message.Value,cancellationToken);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;case &quot;CalculationCompleted&quot;:&#10;&#9;&#9;&#9;&#9;&#9;await ProcessCalculationCompletedEvent(result.Message.Value,cancellationToken);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;default:&#10;&#9;&#9;&#9;&#9;&#9;_logger.LogWarning(&quot;Unknown event type: {EventType} for message key: {Key}&quot;,eventType,result.Message.Key);&#10;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;_logger.LogDebug(&quot;Successfully processed Kafka message. Topic: {Topic}, Key: {Key}, Offset: {Offset}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Message.Key,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Offset);&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &quot;Error processing Kafka message. Topic: {Topic}, Key: {Key}, Offset: {Offset}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Message?.Key,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9; result.Offset);&#10;&#9;&#9;&#9;throw; // Re-throw to prevent commit&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private async Task ProcessCalculationStartedEvent(string messageValue,CancellationToken cancellationToken) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var calculationEvent = JsonSerializer.Deserialize&lt;CalculationStartedEvent&gt;(messageValue);&#10;&#9;&#9;&#9;if (calculationEvent == null)&#10;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;using var scope = _serviceProvider.CreateScope();&#10;&#9;&#9;&#9;var logger = scope.ServiceProvider.GetRequiredService&lt;ILogger&lt;KafkaConsumerService&gt;&gt;();&#10;&#9;&#9;&#9;logger.LogInformation(&quot;Processing calculation started event for operation {OperationId}: {Operation}({X}, {Y})&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Operation,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.X,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Y);&#10;&#10;&#9;&#9;&#9;// Here you could add business logic like:&#10;&#9;&#9;&#9;// - Updating operation status in database&#10;&#9;&#9;&#9;// - Sending notifications&#10;&#9;&#9;&#9;// - Triggering other workflows&#10;&#9;&#9;&#9;// - Metrics collection&#10;&#9;&#9;&#9;await Task.CompletedTask; // Placeholder for actual processing&#10;&#9;&#9;}&#10;&#9;&#9;catch (JsonException ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to deserialize CalculationStartedEvent: {MessageValue}&quot;,messageValue);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private async Task ProcessCalculationCompletedEvent(string messageValue,CancellationToken cancellationToken) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var calculationEvent = JsonSerializer.Deserialize&lt;CalculationCompletedEvent&gt;(messageValue);&#10;&#9;&#9;&#9;if (calculationEvent == null)&#10;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;using var scope = _serviceProvider.CreateScope();&#10;&#9;&#9;&#9;var logger = scope.ServiceProvider.GetRequiredService&lt;ILogger&lt;KafkaConsumerService&gt;&gt;();&#10;&#9;&#9;&#9;logger.LogInformation(&quot;Processing calculation completed event for operation {OperationId}: Success={Success}, Result={Result}, ExecutionTime={ExecutionTime}ms, CacheHit={CacheHit}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Success,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.Result,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.ExecutionTimeMs,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  calculationEvent.CacheHit);&#10;&#10;&#9;&#9;&#9;// Here you could add business logic like:&#10;&#9;&#9;&#9;// - Updating final operation status in database&#10;&#9;&#9;&#9;// - Sending completion notifications&#10;&#9;&#9;&#9;// - Updating analytics/metrics&#10;&#9;&#9;&#9;// - Triggering downstream processes&#10;&#9;&#9;&#9;// - Audit logging&#10;&#9;&#9;&#9;await Task.CompletedTask; // Placeholder for actual processing&#10;&#9;&#9;}&#10;&#9;&#9;catch (JsonException ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to deserialize CalculationCompletedEvent: {MessageValue}&quot;,messageValue);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private static string GetEventTypeFromHeaders(Headers? headers) {&#10;&#9;&#9;if (headers == null)&#10;&#9;&#9;&#9;return &quot;Unknown&quot;;&#10;&#9;&#9;var eventTypeHeader = headers.FirstOrDefault(h =&gt; h.Key == &quot;eventType&quot;);&#10;&#9;&#9;return eventTypeHeader != null ? System.Text.Encoding.UTF8.GetString(eventTypeHeader.GetValueBytes()) : &quot;Unknown&quot;;&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Services/Kafka/KafkaProducerService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Services/Kafka/KafkaProducerService.cs" />
              <option name="originalContent" value="using Confluent.Kafka;&#10;using IO.Swagger.Models.Kafka;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Services.Kafka;&#10;&#10;public interface IKafkaProducerService {&#10;&#9;Task SendCalculationStartedAsync(CalculationStartedEvent calculationEvent);&#10;&#9;Task SendCalculationCompletedAsync(CalculationCompletedEvent calculationEvent);&#10;}&#10;&#10;public class KafkaProducerService : IKafkaProducerService,IDisposable {&#10;&#9;private readonly IProducer&lt;string,string&gt; _producer;&#10;&#9;private readonly ILogger&lt;KafkaProducerService&gt; _logger;&#10;&#9;private readonly string _calculationStartedTopic;&#10;&#9;private readonly string _calculationCompletedTopic;&#10;&#10;&#9;public KafkaProducerService(IConfiguration configuration,ILogger&lt;KafkaProducerService&gt; logger) {&#10;&#9;&#9;_logger = logger;&#10;&#9;&#9;_calculationStartedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationStarted&quot;) ?? &quot;calculation-started&quot;;&#10;&#9;&#9;_calculationCompletedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationCompleted&quot;) ?? &quot;calculation-completed&quot;;&#10;&#9;&#9;var config = new ProducerConfig {&#10;&#9;&#9;&#9;BootstrapServers = configuration.GetConnectionString(&quot;kafka&quot;) ?? &quot;localhost:9092&quot;,&#10;&#9;&#9;&#9;ClientId = &quot;io-swagger-producer&quot;,&#10;&#9;&#9;&#9;Acks = Acks.Leader,&#10;&#9;&#9;&#9;EnableIdempotence = true,&#10;&#9;&#9;&#9;MessageTimeoutMs = 30000,&#10;&#9;&#9;&#9;RequestTimeoutMs = 30000,&#10;&#9;&#9;&#9;DeliveryReportFields = &quot;all&quot;,&#10;&#9;&#9;&#9;CompressionType = CompressionType.Snappy&#10;&#9;&#9;};&#10;&#9;&#9;_producer = new ProducerBuilder&lt;string,string&gt;(config).SetErrorHandler((_,e) =&gt; _logger.LogError(&quot;Kafka producer error: {Error}&quot;,e))&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetLogHandler((_,log) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  if (log.Level &lt;= SyslogLevel.Warning)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogWarning(&quot;Kafka log: {Message}&quot;,log.Message);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .Build();&#10;&#9;}&#10;&#10;&#9;public async Task SendCalculationStartedAsync(CalculationStartedEvent calculationEvent) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var json = JsonSerializer.Serialize(calculationEvent);&#10;&#9;&#9;&#9;var message = new Message&lt;string,string&gt; {&#10;&#9;&#9;&#9;&#9;Key = calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;Value = json,&#10;&#9;&#9;&#9;&#9;Headers = new Headers {&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;eventType&quot;,System.Text.Encoding.UTF8.GetBytes(&quot;CalculationStarted&quot;) },&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;timestamp&quot;,System.Text.Encoding.UTF8.GetBytes(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString()) }&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;};&#10;&#9;&#9;&#9;var result = await _producer.ProduceAsync(_calculationStartedTopic,message);&#10;&#9;&#9;&#9;_logger.LogInformation(&quot;Calculation started event sent to Kafka. Topic: {Topic}, Partition: {Partition}, Offset: {Offset}, OperationId: {OperationId}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Partition.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Offset.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   calculationEvent.OperationId);&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to send calculation started event to Kafka for operation {OperationId}&quot;,calculationEvent.OperationId);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;public async Task SendCalculationCompletedAsync(CalculationCompletedEvent calculationEvent) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var json = JsonSerializer.Serialize(calculationEvent);&#10;&#9;&#9;&#9;var message = new Message&lt;string,string&gt; {&#10;&#9;&#9;&#9;&#9;Key = calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;Value = json,&#10;&#9;&#9;&#9;&#9;Headers = new Headers {&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;eventType&quot;,System.Text.Encoding.UTF8.GetBytes(&quot;CalculationCompleted&quot;) },&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;timestamp&quot;,System.Text.Encoding.UTF8.GetBytes(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString()) }&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;};&#10;&#9;&#9;&#9;var result = await _producer.ProduceAsync(_calculationCompletedTopic,message);&#10;&#9;&#9;&#9;_logger.LogInformation(&quot;Calculation completed event sent to Kafka. Topic: {Topic}, Partition: {Partition}, Offset: {Offset}, OperationId: {OperationId}, Success: {Success}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Partition.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Offset.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   calculationEvent.Success);&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to send calculation completed event to Kafka for operation {OperationId}&quot;,calculationEvent.OperationId);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;public void Dispose() {&#10;&#9;&#9;_producer?.Flush();&#10;&#9;&#9;_producer?.Dispose();&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="using Confluent.Kafka;&#10;using IO.Swagger.Models.Kafka;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Services.Kafka;&#10;&#10;public interface IKafkaProducerService {&#10;&#9;Task SendCalculationStartedAsync(CalculationStartedEvent calculationEvent);&#10;&#9;Task SendCalculationCompletedAsync(CalculationCompletedEvent calculationEvent);&#10;}&#10;&#10;public class KafkaProducerService : IKafkaProducerService,IDisposable {&#10;&#9;private readonly IProducer&lt;string,string&gt; _producer;&#10;&#9;private readonly ILogger&lt;KafkaProducerService&gt; _logger;&#10;&#9;private readonly string _calculationStartedTopic;&#10;&#9;private readonly string _calculationCompletedTopic;&#10;&#10;&#9;public KafkaProducerService(IConfiguration configuration,ILogger&lt;KafkaProducerService&gt; logger) {&#10;&#9;&#9;_logger = logger;&#10;&#9;&#9;_calculationStartedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationStarted&quot;) ?? &quot;calculation-started&quot;;&#10;&#9;&#9;_calculationCompletedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationCompleted&quot;) ?? &quot;calculation-completed&quot;;&#10;&#9;&#9;var config = new ProducerConfig {&#10;&#9;&#9;&#9;BootstrapServers = configuration.GetConnectionString(&quot;kafka&quot;) ?? &quot;localhost:9092&quot;,&#10;&#9;&#9;&#9;ClientId = &quot;io-swagger-producer&quot;,&#10;&#9;&#9;&#9;Acks = Acks.All, // Required when EnableIdempotence is true&#10;&#9;&#9;&#9;EnableIdempotence = true,&#10;&#9;&#9;&#9;MessageTimeoutMs = 30000,&#10;&#9;&#9;&#9;RequestTimeoutMs = 30000,&#10;&#9;&#9;&#9;DeliveryReportFields = &quot;all&quot;,&#10;&#9;&#9;&#9;CompressionType = CompressionType.Snappy&#10;&#9;&#9;};&#10;&#9;&#9;_producer = new ProducerBuilder&lt;string,string&gt;(config).SetErrorHandler((_,e) =&gt; _logger.LogError(&quot;Kafka producer error: {Error}&quot;,e))&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .SetLogHandler((_,log) =&gt; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  if (log.Level &lt;= SyslogLevel.Warning)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  _logger.LogWarning(&quot;Kafka log: {Message}&quot;,log.Message);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  })&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  .Build();&#10;&#9;}&#10;&#10;&#9;public async Task SendCalculationStartedAsync(CalculationStartedEvent calculationEvent) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var json = JsonSerializer.Serialize(calculationEvent);&#10;&#9;&#9;&#9;var message = new Message&lt;string,string&gt; {&#10;&#9;&#9;&#9;&#9;Key = calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;Value = json,&#10;&#9;&#9;&#9;&#9;Headers = new Headers {&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;eventType&quot;,System.Text.Encoding.UTF8.GetBytes(&quot;CalculationStarted&quot;) },&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;timestamp&quot;,System.Text.Encoding.UTF8.GetBytes(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString()) }&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;};&#10;&#9;&#9;&#9;var result = await _producer.ProduceAsync(_calculationStartedTopic,message);&#10;&#9;&#9;&#9;_logger.LogInformation(&quot;Calculation started event sent to Kafka. Topic: {Topic}, Partition: {Partition}, Offset: {Offset}, OperationId: {OperationId}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Partition.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Offset.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   calculationEvent.OperationId);&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to send calculation started event to Kafka for operation {OperationId}&quot;,calculationEvent.OperationId);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;public async Task SendCalculationCompletedAsync(CalculationCompletedEvent calculationEvent) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;var json = JsonSerializer.Serialize(calculationEvent);&#10;&#9;&#9;&#9;var message = new Message&lt;string,string&gt; {&#10;&#9;&#9;&#9;&#9;Key = calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;Value = json,&#10;&#9;&#9;&#9;&#9;Headers = new Headers {&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;eventType&quot;,System.Text.Encoding.UTF8.GetBytes(&quot;CalculationCompleted&quot;) },&#10;&#9;&#9;&#9;&#9;&#9;{ &quot;timestamp&quot;,System.Text.Encoding.UTF8.GetBytes(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString()) }&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;};&#10;&#9;&#9;&#9;var result = await _producer.ProduceAsync(_calculationCompletedTopic,message);&#10;&#9;&#9;&#9;_logger.LogInformation(&quot;Calculation completed event sent to Kafka. Topic: {Topic}, Partition: {Partition}, Offset: {Offset}, OperationId: {OperationId}, Success: {Success}&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Topic,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Partition.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   result.Offset.Value,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   calculationEvent.OperationId,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   calculationEvent.Success);&#10;&#9;&#9;}&#10;&#9;&#9;catch (Exception ex) {&#10;&#9;&#9;&#9;_logger.LogError(ex,&quot;Failed to send calculation completed event to Kafka for operation {OperationId}&quot;,calculationEvent.OperationId);&#10;&#9;&#9;&#9;throw;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;public void Dispose() {&#10;&#9;&#9;_producer?.Flush();&#10;&#9;&#9;_producer?.Dispose();&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Services/RadisService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Services/RadisService.cs" />
              <option name="originalContent" value="using IO.Swagger.Models.Math;&#10;using StackExchange.Redis;&#10;&#10;namespace IO.Swagger.Services;&#10;&#10;public class RadisService(IConnectionMultiplexer redis) {&#10;&#9;private string GetMathKey(MathRequest model) =&gt; $&quot;{model.Operation}:{model.X}:{model.Y}&quot;;&#10;&#9;&#10;&#9;public Task&lt;bool&gt; IsMathKeyExistsAsync(string key) =&gt; redis.GetDatabase().KeyExistsAsync(key);&#10;&#9;public Task SetMathDataAsync(MathRequest data,double result,TimeSpan ttl) =&gt; redis.GetDatabase().StringSetAsync(GetMathKey(data),result,ttl);&#10;&#9;public async Task&lt;double?&gt; GetMathDataAsync(string key) =&gt; &#10;&#9;&#9;await redis.GetDatabase().&#10;&#9;&#9;&#9;&#9;&#9;StringGetAsync(key).&#10;&#9;&#9;&#9;&#9;&#9;ContinueWith(x =&gt; x.Result.IsNullOrEmpty &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  ? null &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  : double.TryParse(x.Result.ToString(),out var result) ? result : default(double?));&#10;}&#10;" />
              <option name="updatedContent" value="using IO.Swagger.Models.Math;&#10;using Microsoft.AspNetCore.Http;&#10;using StackExchange.Redis;&#10;&#10;namespace IO.Swagger.Services;&#10;&#10;public class RadisService(IConnectionMultiplexer redis) {&#10;&#9;private string GetMathKey(MathRequest model) =&gt; $&quot;{model.Operation}:{model.X}:{model.Y}&quot;;&#10;&#9;&#10;&#9;public Task&lt;bool&gt; IsMathKeyExistsAsync(string key) =&gt; redis.GetDatabase().KeyExistsAsync(key);&#10;&#9;public Task SetMathDataAsync(MathRequest data,double result,TimeSpan ttl) =&gt; redis.GetDatabase().StringSetAsync(GetMathKey(data),result,ttl);&#10;&#9;public async Task&lt;double?&gt; GetMathDataAsync(string key) =&gt; &#10;&#9;&#9;await redis.GetDatabase().&#10;&#9;&#9;&#9;&#9;&#9;StringGetAsync(key).&#10;&#9;&#9;&#9;&#9;&#9;ContinueWith(x =&gt; x.Result.IsNullOrEmpty &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  ? null &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  : double.TryParse(x.Result.ToString(),out var result) ? result : default(double?));&#10;&#9;public string GetCustomCacheKey(HttpContext context)&#10;&#9;{&#10;&#9;&#9;// Example: Use a header, query, or body value to choose the key&#10;&#9;&#9;// You can customize this logic as needed&#10;&#9;&#9;if (context.Request.Path.StartsWithSegments(&quot;/api/path&quot;) &amp;&amp; context.Request.Method == &quot;POST&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// Example: Use a custom header or query param as cache key&#10;&#9;&#9;&#9;var customKey = context.Request.Headers[&quot;X-Cache-Key&quot;].FirstOrDefault();&#10;&#9;&#9;&#9;if (!string.IsNullOrEmpty(customKey))&#10;&#9;&#9;&#9;&#9;return $&quot;custom:{customKey}&quot;;&#10;&#10;&#9;&#9;&#9;// Fallback: Use request body hash or other logic&#10;&#9;&#9;&#9;return $&quot;custom:{context.Connection.Id}&quot;;&#10;&#9;&#9;}&#10;&#9;&#9;return null;&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Tests/AuthenticationIntegrationTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Tests/AuthenticationIntegrationTests.cs" />
              <option name="originalContent" value="using Aspire.Hosting.Testing;&#10;using IO.Swagger.Models.Token;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using System.Net.Http.Headers;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;public class AuthenticationIntegrationTests&#10;{&#10;    [Theory]&#10;    [InlineData(&quot;testuser&quot;)]&#10;    [InlineData(&quot;admin&quot;)]&#10;    [InlineData(&quot;user123&quot;)]&#10;    [InlineData(&quot;api_user&quot;)]&#10;    public async Task AuthApi_ValidTokenRequest_ReturnsValidToken(string username)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var tokenRequest = new TokenRequest { Username = username };&#10;        &#10;        // Act&#10;        var response = await httpClient.PostAsJsonAsync(&quot;/api/auth/token&quot;, tokenRequest);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode);&#10;        &#10;        var tokenResponse = await response.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        Assert.NotNull(tokenResponse);&#10;        Assert.NotNull(tokenResponse.Token);&#10;        Assert.Equal(&quot;Bearer&quot;, tokenResponse.TokenType);&#10;        Assert.Equal(username, tokenResponse.Username);&#10;        Assert.True(tokenResponse.ExpiresAt &gt; DateTime.UtcNow);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;&quot;)]&#10;    [InlineData(&quot;   &quot;)]&#10;    public async Task AuthApi_InvalidUsername_ReturnsBadRequest(string username)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var tokenRequest = new TokenRequest { Username = username };&#10;        &#10;        // Act&#10;        var response = await httpClient.PostAsJsonAsync(&quot;/api/auth/token&quot;, tokenRequest);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.BadRequest, response.StatusCode);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task AuthApi_EmptyRequest_ReturnsBadRequest()&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var jsonContent = new StringContent(&#10;            &quot;{}&quot;,&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;        &#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/auth/token&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.BadRequest, response.StatusCode);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;testuser&quot;)]&#10;    [InlineData(&quot;admin&quot;)]&#10;    [InlineData(&quot;api_user&quot;)]&#10;    public async Task ProtectedEndpoint_ValidToken_AllowsAccess(string username)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        // Get a valid token first&#10;        var tokenRequest = new TokenRequest { Username = username };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/auth/token&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        // Set authorization header&#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token.Token);&#10;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#10;        {&#10;            Operation = IO.Swagger.Models.Math.MathOperationType.AddEnum,&#10;            X = 10.0,&#10;            Y = 5.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;&quot;)]&#10;    [InlineData(&quot;invalid.token.here&quot;)]&#10;    [InlineData(&quot;Bearer invalid_token&quot;)]&#10;    [InlineData(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid&quot;)]&#10;    public async Task ProtectedEndpoint_InvalidToken_ReturnsUnauthorized(string invalidToken)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        // Set invalid authorization header&#10;        if (!string.IsNullOrEmpty(invalidToken))&#10;        {&#10;            if (invalidToken.StartsWith(&quot;Bearer &quot;))&#10;            {&#10;                httpClient.DefaultRequestHeaders.Authorization = &#10;                    AuthenticationHeaderValue.Parse(invalidToken);&#10;            }&#10;            else&#10;            {&#10;                httpClient.DefaultRequestHeaders.Authorization = &#10;                    new AuthenticationHeaderValue(&quot;Bearer&quot;, invalidToken);&#10;            }&#10;        }&#10;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#10;        {&#10;            Operation = IO.Swagger.Models.Math.MathOperationType.AddEnum,&#10;            X = 10.0,&#10;            Y = 5.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, response.StatusCode);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task ProtectedEndpoint_NoToken_ReturnsUnauthorized()&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#10;        {&#10;            Operation = IO.Swagger.Models.Math.MathOperationType.AddEnum,&#10;            X = 10.0,&#10;            Y = 5.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, response.StatusCode);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;testuser&quot;, IO.Swagger.Models.Math.MathOperationType.DivideEnum, 10.0, 0.0)]&#10;    [InlineData(&quot;admin&quot;, IO.Swagger.Models.Math.MathOperationType.DivideEnum, -5.0, 0.0)]&#10;    [InlineData(&quot;api_user&quot;, IO.Swagger.Models.Math.MathOperationType.DivideEnum, 0.0, 0.0)]&#10;    public async Task AuthenticatedDivideByZero_ValidToken_ReturnsErrorResponse(string username, IO.Swagger.Models.Math.MathOperationType operation, double x, double y)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        // Get a valid token first&#10;        var tokenRequest = new TokenRequest { Username = username };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/auth/token&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        // Set authorization header&#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token.Token);&#10;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode || response.StatusCode == System.Net.HttpStatusCode.BadRequest);&#10;        &#10;        var responseContent = await response.Content.ReadAsStringAsync();&#10;        var mathResponse = JsonSerializer.Deserialize&lt;IO.Swagger.Models.MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true&#10;        });&#10;&#10;        Assert.NotNull(mathResponse);&#10;        Assert.False(mathResponse.Success);&#10;        Assert.NotNull(mathResponse.Error);&#10;        Assert.Contains(&quot;division by zero&quot;, mathResponse.Error.ToLower());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Aspire.Hosting.Testing;&#13;&#10;using IO.Swagger.Models.Token;&#13;&#10;using Microsoft.Extensions.DependencyInjection;&#13;&#10;using System.Net.Http.Headers;&#13;&#10;using System.Net.Http.Json;&#13;&#10;using System.Text;&#13;&#10;using System.Text.Json;&#13;&#10;using Xunit;&#13;&#10;&#13;&#10;namespace IO.Swagger.Tests;&#13;&#10;&#13;&#10;public class AuthenticationIntegrationTests&#13;&#10;{&#13;&#10;    [Theory]&#13;&#10;    [InlineData(&quot;testuser&quot;)]&#13;&#10;    [InlineData(&quot;admin&quot;)]&#13;&#10;    [InlineData(&quot;user123&quot;)]&#13;&#10;    [InlineData(&quot;api_user&quot;)]&#13;&#10;    public async Task AuthApi_ValidTokenRequest_ReturnsValidToken(string username)&#13;&#10;    {&#13;&#10;        // Arrange&#13;&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#13;&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#13;&#10;        {&#13;&#10;            clientBuilder.AddStandardResilienceHandler();&#13;&#10;        });&#13;&#10;        await using var app = await appHost.BuildAsync();&#13;&#10;        await app.StartAsync();&#13;&#10;&#13;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#13;&#10;        &#13;&#10;        var tokenRequest = new TokenRequest { Username = username };&#13;&#10;        &#13;&#10;        // Act&#13;&#10;        var response = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#13;&#10;&#13;&#10;        // Assert&#13;&#10;        Assert.True(response.IsSuccessStatusCode);&#13;&#10;        &#13;&#10;        var tokenResponse = await response.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#13;&#10;        Assert.NotNull(tokenResponse);&#13;&#10;        Assert.NotNull(tokenResponse.Token);&#13;&#10;        Assert.Equal(&quot;Bearer&quot;, tokenResponse.TokenType);&#13;&#10;        Assert.Equal(username, tokenResponse.Username);&#13;&#10;        Assert.True(tokenResponse.ExpiresAt &gt; DateTime.UtcNow);&#13;&#10;    }&#13;&#10;&#13;&#10;    [Theory]&#13;&#10;    [InlineData(&quot;&quot;)]&#13;&#10;    [InlineData(&quot;   &quot;)]&#13;&#10;    public async Task AuthApi_InvalidUsername_ReturnsBadRequest(string username)&#13;&#10;    {&#13;&#10;        // Arrange&#13;&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#13;&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#13;&#10;        {&#13;&#10;            clientBuilder.AddStandardResilienceHandler();&#13;&#10;        });&#13;&#10;        await using var app = await appHost.BuildAsync();&#13;&#10;        await app.StartAsync();&#13;&#10;&#13;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#13;&#10;        &#13;&#10;        var tokenRequest = new TokenRequest { Username = username };&#13;&#10;        &#13;&#10;        // Act&#13;&#10;        var response = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#13;&#10;&#13;&#10;        // Assert&#13;&#10;        Assert.Equal(System.Net.HttpStatusCode.BadRequest, response.StatusCode);&#13;&#10;    }&#13;&#10;&#13;&#10;    [Fact]&#13;&#10;    public async Task AuthApi_EmptyRequest_ReturnsBadRequest()&#13;&#10;    {&#13;&#10;        // Arrange&#13;&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#13;&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#13;&#10;        {&#13;&#10;            clientBuilder.AddStandardResilienceHandler();&#13;&#10;        });&#13;&#10;        await using var app = await appHost.BuildAsync();&#13;&#10;        await app.StartAsync();&#13;&#10;&#13;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#13;&#10;        &#13;&#10;        var jsonContent = new StringContent(&#13;&#10;            &quot;{}&quot;,&#13;&#10;            Encoding.UTF8,&#13;&#10;            &quot;application/json&quot;);&#13;&#10;        &#13;&#10;        // Act&#13;&#10;        var response = await httpClient.PostAsync(&quot;/api/token/generate&quot;, jsonContent);&#13;&#10;&#13;&#10;        // Assert&#13;&#10;        Assert.Equal(System.Net.HttpStatusCode.BadRequest, response.StatusCode);&#13;&#10;    }&#13;&#10;&#13;&#10;    [Theory]&#13;&#10;    [InlineData(&quot;testuser&quot;)]&#13;&#10;    [InlineData(&quot;admin&quot;)]&#13;&#10;    [InlineData(&quot;api_user&quot;)]&#13;&#10;    public async Task ProtectedEndpoint_ValidToken_AllowsAccess(string username)&#13;&#10;    {&#13;&#10;        // Arrange&#13;&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#13;&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#13;&#10;        {&#13;&#10;            clientBuilder.AddStandardResilienceHandler();&#13;&#10;        });&#13;&#10;        await using var app = await appHost.BuildAsync();&#13;&#10;        await app.StartAsync();&#13;&#10;&#13;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#13;&#10;        &#13;&#10;        // Get a valid token first&#13;&#10;        var tokenRequest = new TokenRequest { Username = username };&#13;&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#13;&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#13;&#10;        &#13;&#10;        // Set authorization header&#13;&#10;        httpClient.DefaultRequestHeaders.Authorization = &#13;&#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token.Token);&#13;&#10;&#13;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#13;&#10;        {&#13;&#10;            Operation = IO.Swagger.Models.Math.MathOperationType.AddEnum,&#13;&#10;            X = 10.0,&#13;&#10;            Y = 5.0&#13;&#10;        };&#13;&#10;&#13;&#10;        var jsonContent = new StringContent(&#13;&#10;            JsonSerializer.Serialize(mathRequest),&#13;&#10;            Encoding.UTF8,&#13;&#10;            &quot;application/json&quot;);&#13;&#10;&#13;&#10;        // Act&#13;&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#13;&#10;&#13;&#10;        // Assert&#13;&#10;        Assert.True(response.IsSuccessStatusCode);&#13;&#10;    }&#13;&#10;&#13;&#10;    [Theory]&#13;&#10;    [InlineData(&quot;&quot;)]&#13;&#10;    [InlineData(&quot;invalid.token.here&quot;)]&#13;&#10;    [InlineData(&quot;Bearer invalid_token&quot;)]&#13;&#10;    [InlineData(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid&quot;)]&#13;&#10;    public async Task ProtectedEndpoint_InvalidToken_ReturnsUnauthorized(string invalidToken)&#13;&#10;    {&#13;&#10;        // Arrange&#13;&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#13;&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#13;&#10;        {&#13;&#10;            clientBuilder.AddStandardResilienceHandler();&#13;&#10;        });&#13;&#10;        await using var app = await appHost.BuildAsync();&#13;&#10;        await app.StartAsync();&#13;&#10;&#13;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#13;&#10;        &#13;&#10;        // Set invalid authorization header&#13;&#10;        if (!string.IsNullOrEmpty(invalidToken))&#13;&#10;        {&#13;&#10;            if (invalidToken.StartsWith(&quot;Bearer &quot;))&#13;&#10;            {&#13;&#10;                httpClient.DefaultRequestHeaders.Authorization = &#13;&#10;                    AuthenticationHeaderValue.Parse(invalidToken);&#13;&#10;            }&#13;&#10;            else&#13;&#10;            {&#13;&#10;                httpClient.DefaultRequestHeaders.Authorization = &#13;&#10;                    new AuthenticationHeaderValue(&quot;Bearer&quot;, invalidToken);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#13;&#10;        {&#13;&#10;            Operation = IO.Swagger.Models.Math.MathOperationType.AddEnum,&#13;&#10;            X = 10.0,&#13;&#10;            Y = 5.0&#13;&#10;        };&#13;&#10;&#13;&#10;        var jsonContent = new StringContent(&#13;&#10;            JsonSerializer.Serialize(mathRequest),&#13;&#10;            Encoding.UTF8,&#13;&#10;            &quot;application/json&quot;);&#13;&#10;&#13;&#10;        // Act&#13;&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#13;&#10;&#13;&#10;        // Assert&#13;&#10;        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, response.StatusCode);&#13;&#10;    }&#13;&#10;&#13;&#10;    [Fact]&#13;&#10;    public async Task ProtectedEndpoint_NoToken_ReturnsUnauthorized()&#13;&#10;    {&#13;&#10;        // Arrange&#13;&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#13;&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#13;&#10;        {&#13;&#10;            clientBuilder.AddStandardResilienceHandler();&#13;&#10;        });&#13;&#10;        await using var app = await appHost.BuildAsync();&#13;&#10;        await app.StartAsync();&#13;&#10;&#13;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#13;&#10;&#13;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#13;&#10;        {&#13;&#10;            Operation = IO.Swagger.Models.Math.MathOperationType.AddEnum,&#13;&#10;            X = 10.0,&#13;&#10;            Y = 5.0&#13;&#10;        };&#13;&#10;&#13;&#10;        var jsonContent = new StringContent(&#13;&#10;            JsonSerializer.Serialize(mathRequest),&#13;&#10;            Encoding.UTF8,&#13;&#10;            &quot;application/json&quot;);&#13;&#10;&#13;&#10;        // Act&#13;&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#13;&#10;&#13;&#10;        // Assert&#13;&#10;        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, response.StatusCode);&#13;&#10;    }&#13;&#10;&#13;&#10;    [Theory]&#13;&#10;    [InlineData(&quot;testuser&quot;, IO.Swagger.Models.Math.MathOperationType.DivideEnum, 10.0, 0.0)]&#13;&#10;    [InlineData(&quot;admin&quot;, IO.Swagger.Models.Math.MathOperationType.DivideEnum, -5.0, 0.0)]&#13;&#10;    [InlineData(&quot;api_user&quot;, IO.Swagger.Models.Math.MathOperationType.DivideEnum, 0.0, 0.0)]&#13;&#10;    public async Task AuthenticatedDivideByZero_ValidToken_ReturnsErrorResponse(string username, IO.Swagger.Models.Math.MathOperationType operation, double x, double y)&#13;&#10;    {&#13;&#10;        // Arrange&#13;&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#13;&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#13;&#10;        {&#13;&#10;            clientBuilder.AddStandardResilienceHandler();&#13;&#10;        });&#13;&#10;        await using var app = await appHost.BuildAsync();&#13;&#10;        await app.StartAsync();&#13;&#10;&#13;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#13;&#10;        &#13;&#10;        // Get a valid token first&#13;&#10;        var tokenRequest = new TokenRequest { Username = username };&#13;&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#13;&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#13;&#10;        &#13;&#10;        // Set authorization header&#13;&#10;        httpClient.DefaultRequestHeaders.Authorization = &#13;&#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token.Token);&#13;&#10;&#13;&#10;        var mathRequest = new IO.Swagger.Models.Math.MathRequest&#13;&#10;        {&#13;&#10;            Operation = operation,&#13;&#10;            X = x,&#13;&#10;            Y = y&#13;&#10;        };&#13;&#10;&#13;&#10;        var jsonContent = new StringContent(&#13;&#10;            JsonSerializer.Serialize(mathRequest),&#13;&#10;            Encoding.UTF8,&#13;&#10;            &quot;application/json&quot;);&#13;&#10;&#13;&#10;        // Act&#13;&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#13;&#10;&#13;&#10;        // Assert&#13;&#10;        Assert.True(response.IsSuccessStatusCode || response.StatusCode == System.Net.HttpStatusCode.BadRequest);&#13;&#10;        &#13;&#10;        var responseContent = await response.Content.ReadAsStringAsync();&#13;&#10;        var mathResponse = JsonSerializer.Deserialize&lt;IO.Swagger.Models.MathResponse&gt;(responseContent, new JsonSerializerOptions&#13;&#10;        {&#13;&#10;            PropertyNameCaseInsensitive = true&#13;&#10;        });&#13;&#10;&#13;&#10;        Assert.NotNull(mathResponse);&#13;&#10;        Assert.False(mathResponse.Success);&#13;&#10;        Assert.NotNull(mathResponse.Error);&#13;&#10;        Assert.Contains(&quot;division by zero&quot;, mathResponse.Error.ToLower());&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Tests/AuthenticationServiceTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Tests/AuthenticationServiceTests.cs" />
              <option name="originalContent" value="using IO.Swagger.Models.Token;&#10;using IO.Swagger.Services;&#10;using Microsoft.Extensions.Configuration;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;public class AuthenticationServiceTests&#10;{&#10;    private readonly IConfiguration _configuration;&#10;    private readonly AuthenticationService _authService;&#10;&#10;    public AuthenticationServiceTests()&#10;    {&#10;        var configurationBuilder = new ConfigurationBuilder();&#10;        configurationBuilder.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;&#10;        {&#10;            {&quot;Jwt:Key&quot;, &quot;ThisIsASecretKeyForJWTTokenGenerationWithMinimum256BitsLength&quot;},&#10;            {&quot;Jwt:Issuer&quot;, &quot;TestIssuer&quot;},&#10;            {&quot;Jwt:Audience&quot;, &quot;TestAudience&quot;},&#10;            {&quot;Jwt:ExpiryInMinutes&quot;, &quot;30&quot;}&#10;        });&#10;        _configuration = configurationBuilder.Build();&#10;        _authService = new AuthenticationService(_configuration);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;testuser&quot;)]&#10;    [InlineData(&quot;admin&quot;)]&#10;    [InlineData(&quot;user123&quot;)]&#10;    public void GenerateToken_ValidUsername_ReturnsValidToken(string username)&#10;    {&#10;        // Arrange&#10;        var request = new TokenRequest { Username = username };&#10;&#10;        // Act&#10;        var result = _authService.GenerateToken(request);&#10;&#10;        // Assert&#10;        Assert.NotNull(result);&#10;        Assert.NotNull(result.Token);&#10;        Assert.Equal(&quot;Bearer&quot;, result.TokenType);&#10;        Assert.Equal(username, result.Username);&#10;        Assert.True(result.ExpiresAt &gt; DateTime.UtcNow);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(null)]&#10;    [InlineData(&quot;&quot;)]&#10;    [InlineData(&quot;   &quot;)]&#10;    public void GenerateToken_InvalidUsername_ThrowsArgumentException(string? username)&#10;    {&#10;        // Arrange&#10;        var request = new TokenRequest { Username = username };&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; _authService.GenerateToken(request));&#10;    }&#10;&#10;    [Fact]&#10;    public void GenerateToken_NullRequest_ThrowsArgumentException()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; _authService.GenerateToken(null));&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;testuser&quot;)]&#10;    [InlineData(&quot;admin&quot;)]&#10;    [InlineData(&quot;user123&quot;)]&#10;    public void ValidateToken_ValidToken_ReturnsTrue(string username)&#10;    {&#10;        // Arrange&#10;        var request = new TokenRequest { Username = username };&#10;        var tokenResponse = _authService.GenerateToken(request);&#10;&#10;        // Act&#10;        var isValid = _authService.ValidateToken(tokenResponse.Token);&#10;&#10;        // Assert&#10;        Assert.True(isValid);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;&quot;)]&#10;    [InlineData(&quot;invalid.token.here&quot;)]&#10;    [InlineData(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid&quot;)]&#10;    [InlineData(null)]&#10;    public void ValidateToken_InvalidToken_ReturnsFalse(string? token)&#10;    {&#10;        // Act&#10;        var isValid = _authService.ValidateToken(token);&#10;&#10;        // Assert&#10;        Assert.False(isValid);&#10;    }&#10;&#10;    [Fact]&#10;    public void ValidateToken_ExpiredToken_ReturnsFalse()&#10;    {&#10;        // Arrange - Create configuration with very short expiry&#10;        var shortExpiryConfig = new ConfigurationBuilder()&#10;            .AddInMemoryCollection(new Dictionary&lt;string, string?&gt;&#10;            {&#10;                {&quot;Jwt:Key&quot;, &quot;ThisIsASecretKeyForJWTTokenGenerationWithMinimum256BitsLength&quot;},&#10;                {&quot;Jwt:Issuer&quot;, &quot;TestIssuer&quot;},&#10;                {&quot;Jwt:Audience&quot;, &quot;TestAudience&quot;},&#10;                {&quot;Jwt:ExpiryInMinutes&quot;, &quot;0&quot;} // Expires immediately&#10;            })&#10;            .Build();&#10;        &#10;        var shortExpiryService = new AuthenticationService(shortExpiryConfig);&#10;        var request = new TokenRequest { Username = &quot;testuser&quot; };&#10;        var tokenResponse = shortExpiryService.GenerateToken(request);&#10;&#10;        // Wait a moment to ensure expiry&#10;        Thread.Sleep(1000);&#10;&#10;        // Act&#10;        var isValid = _authService.ValidateToken(tokenResponse.Token);&#10;&#10;        // Assert&#10;        Assert.False(isValid);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;WrongKey&quot;)]&#10;    [InlineData(&quot;DifferentIssuer&quot;)]&#10;    [InlineData(&quot;DifferentAudience&quot;)]&#10;    public void ValidateToken_WrongConfiguration_ReturnsFalse(string configType)&#10;    {&#10;        // Arrange - Create token with original config&#10;        var request = new TokenRequest { Username = &quot;testuser&quot; };&#10;        var tokenResponse = _authService.GenerateToken(request);&#10;&#10;        // Create service with wrong configuration&#10;        var wrongConfig = new Dictionary&lt;string, string?&gt;&#10;        {&#10;            {&quot;Jwt:Key&quot;, &quot;ThisIsASecretKeyForJWTTokenGenerationWithMinimum256BitsLength&quot;},&#10;            {&quot;Jwt:Issuer&quot;, &quot;TestIssuer&quot;},&#10;            {&quot;Jwt:Audience&quot;, &quot;TestAudience&quot;},&#10;            {&quot;Jwt:ExpiryInMinutes&quot;, &quot;30&quot;}&#10;        };&#10;&#10;        switch (configType)&#10;        {&#10;            case &quot;WrongKey&quot;:&#10;                wrongConfig[&quot;Jwt:Key&quot;] = &quot;DifferentSecretKeyForJWTTokenGenerationWith256BitsLength&quot;;&#10;                break;&#10;            case &quot;DifferentIssuer&quot;:&#10;                wrongConfig[&quot;Jwt:Issuer&quot;] = &quot;WrongIssuer&quot;;&#10;                break;&#10;            case &quot;DifferentAudience&quot;:&#10;                wrongConfig[&quot;Jwt:Audience&quot;] = &quot;WrongAudience&quot;;&#10;                break;&#10;        }&#10;&#10;        var wrongConfigBuilder = new ConfigurationBuilder().AddInMemoryCollection(wrongConfig);&#10;        var wrongAuthService = new AuthenticationService(wrongConfigBuilder.Build());&#10;&#10;        // Act&#10;        var isValid = wrongAuthService.ValidateToken(tokenResponse.Token);&#10;&#10;        // Assert&#10;        Assert.False(isValid);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using IO.Swagger.Models.Math;&#10;using IO.Swagger.Models.Token;&#10;using IO.Swagger.Services;&#10;using Microsoft.Extensions.Configuration;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;public class AuthenticationServiceTests&#10;{&#10;    private readonly AuthenticationService _authService;&#10;&#10;    public AuthenticationServiceTests()&#10;    {&#10;        var configurationBuilder = new ConfigurationBuilder();&#10;        configurationBuilder.AddInMemoryCollection(new Dictionary&lt;string, string?&gt;&#10;        {&#10;            {&quot;Jwt:Key&quot;, &quot;ThisIsASecretKeyForJWTTokenGenerationWithMinimum256BitsLength&quot;},&#10;            {&quot;Jwt:Issuer&quot;, &quot;TestIssuer&quot;},&#10;            {&quot;Jwt:Audience&quot;, &quot;TestAudience&quot;},&#10;            {&quot;Jwt:ExpiryInMinutes&quot;, &quot;30&quot;}&#10;        });&#10;        var configuration = configurationBuilder.Build();&#10;        _authService = new AuthenticationService(configuration);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;testuser&quot;)]&#10;    [InlineData(&quot;admin&quot;)]&#10;    [InlineData(&quot;user123&quot;)]&#10;    public void GenerateToken_ValidUsername_ReturnsValidToken(string username)&#10;    {&#10;        // Arrange&#10;        var request = new TokenRequest { Username = username };&#10;&#10;        // Act&#10;        var result = _authService.GenerateToken(request);&#10;&#10;        // Assert&#10;        Assert.NotNull(result);&#10;        Assert.NotNull(result.Token);&#10;        Assert.Equal(&quot;Bearer&quot;, result.TokenType);&#10;        Assert.Equal(username, result.Username);&#10;        Assert.True(result.ExpiresAt &gt; DateTime.UtcNow);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(null)]&#10;    [InlineData(&quot;&quot;)]&#10;    [InlineData(&quot;   &quot;)]&#10;    public void GenerateToken_InvalidUsername_ThrowsArgumentException(string? username)&#10;    {&#10;        // Arrange&#10;        var request = new TokenRequest { Username = username };&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; _authService.GenerateToken(request));&#10;    }&#10;&#10;    [Fact]&#10;    public void GenerateToken_NullRequest_ThrowsArgumentException()&#10;    {&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; _authService.GenerateToken(null));&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;testuser&quot;)]&#10;    [InlineData(&quot;admin&quot;)]&#10;    [InlineData(&quot;user123&quot;)]&#10;    public void ValidateToken_ValidToken_ReturnsTrue(string username)&#10;    {&#10;        // Arrange&#10;        var request = new TokenRequest { Username = username };&#10;        var tokenResponse = _authService.GenerateToken(request);&#10;&#10;        // Act&#10;        var isValid = _authService.ValidateToken(tokenResponse.Token);&#10;&#10;        // Assert&#10;        Assert.True(isValid);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;&quot;)]&#10;    [InlineData(&quot;invalid.token.here&quot;)]&#10;    [InlineData(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid&quot;)]&#10;    [InlineData(null)]&#10;    public void ValidateToken_InvalidToken_ReturnsFalse(string? token)&#10;    {&#10;        // Act&#10;        var isValid = _authService.ValidateToken(token);&#10;&#10;        // Assert&#10;        Assert.False(isValid);&#10;    }&#10;&#10;    [Fact]&#10;    public void ValidateToken_ExpiredToken_ReturnsFalse()&#10;    {&#10;        // Arrange - Create configuration with very short expiry&#10;        var shortExpiryConfig = new ConfigurationBuilder()&#10;            .AddInMemoryCollection(new Dictionary&lt;string, string?&gt;&#10;            {&#10;                {&quot;Jwt:Key&quot;, &quot;ThisIsASecretKeyForJWTTokenGenerationWithMinimum256BitsLength&quot;},&#10;                {&quot;Jwt:Issuer&quot;, &quot;TestIssuer&quot;},&#10;                {&quot;Jwt:Audience&quot;, &quot;TestAudience&quot;},&#10;                {&quot;Jwt:ExpiryInMinutes&quot;, &quot;0&quot;} // Expires immediately&#10;            })&#10;            .Build();&#10;        &#10;        var shortExpiryService = new AuthenticationService(shortExpiryConfig);&#10;        var request = new TokenRequest { Username = &quot;testuser&quot; };&#10;        var tokenResponse = shortExpiryService.GenerateToken(request);&#10;&#10;        // Wait a moment to ensure expiry&#10;        Thread.Sleep(1000);&#10;&#10;        // Act&#10;        var isValid = _authService.ValidateToken(tokenResponse.Token);&#10;&#10;        // Assert&#10;        Assert.False(isValid);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;WrongKey&quot;)]&#10;    [InlineData(&quot;DifferentIssuer&quot;)]&#10;    [InlineData(&quot;DifferentAudience&quot;)]&#10;    public void ValidateToken_WrongConfiguration_ReturnsFalse(string configType)&#10;    {&#10;        // Arrange - Create token with original config&#10;        var request = new TokenRequest { Username = &quot;testuser&quot; };&#10;        var tokenResponse = _authService.GenerateToken(request);&#10;&#10;        // Create service with wrong configuration&#10;        var wrongConfig = new Dictionary&lt;string, string?&gt;&#10;        {&#10;            {&quot;Jwt:Key&quot;, &quot;ThisIsASecretKeyForJWTTokenGenerationWithMinimum256BitsLength&quot;},&#10;            {&quot;Jwt:Issuer&quot;, &quot;TestIssuer&quot;},&#10;            {&quot;Jwt:Audience&quot;, &quot;TestAudience&quot;},&#10;            {&quot;Jwt:ExpiryInMinutes&quot;, &quot;30&quot;}&#10;        };&#10;&#10;        switch (configType)&#10;        {&#10;            case &quot;WrongKey&quot;:&#10;                wrongConfig[&quot;Jwt:Key&quot;] = &quot;DifferentSecretKeyForJWTTokenGenerationWith256BitsLength&quot;;&#10;                break;&#10;            case &quot;DifferentIssuer&quot;:&#10;                wrongConfig[&quot;Jwt:Issuer&quot;] = &quot;WrongIssuer&quot;;&#10;                break;&#10;            case &quot;DifferentAudience&quot;:&#10;                wrongConfig[&quot;Jwt:Audience&quot;] = &quot;WrongAudience&quot;;&#10;                break;&#10;        }&#10;&#10;        var wrongConfigBuilder = new ConfigurationBuilder().AddInMemoryCollection(wrongConfig);&#10;        var wrongAuthService = new AuthenticationService(wrongConfigBuilder.Build());&#10;&#10;        // Act&#10;        var isValid = wrongAuthService.ValidateToken(tokenResponse.Token);&#10;&#10;        // Assert&#10;        Assert.False(isValid);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Tests/ComprehensiveIntegrationTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Tests/ComprehensiveIntegrationTests.cs" />
              <option name="originalContent" value="using System.Net;&#10;using Aspire.Hosting.Testing;&#10;using IO.Swagger.Models.Math;&#10;using IO.Swagger.Models.Token;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using System.Net.Http.Headers;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using IO.Swagger.Models;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;/// &lt;summary&gt;&#10;/// Comprehensive end-to-end tests that validate the complete integration of:&#10;/// - Authentication Service (token validation)&#10;/// - Redis Service (caching)&#10;/// - Math API with divide by zero handling&#10;/// &lt;/summary&gt;&#10;public class ComprehensiveIntegrationTests&#10;{&#10;    [Fact]&#10;    public async Task CompleteWorkflow_AuthenticationAndMathOperations_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder&#10;                          .CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;&#10;        // To output logs to the xUnit.net ITestOutputHelper, &#10;        // consider adding a package from https://www.nuget.org/packages?q=xunit+logging&#10;&#10;        await using var app = await builder.BuildAsync();&#10;&#10;        await app.StartAsync();&#10;&#10;        // Act&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;&#10;        // Step 1: Authenticate and get token&#10;        var tokenRequest = new TokenRequest { Username = &quot;integration_test_user&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        Assert.True(tokenResponse.IsSuccessStatusCode, &quot;Token generation should succeed&quot;);&#10;        &#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        Assert.NotNull(token);&#10;        Assert.NotNull(token.Token);&#10;&#10;        // Step 2: Set authorization header for subsequent requests&#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token.Token);&#10;&#10;        // Step 3: Test successful math operations (these should be cached)&#10;        var successfulOperations = new[]&#10;        {&#10;            new { Operation = MathOperationType.AddEnum, X = 10.0, Y = 5.0, Expected = 15.0 },&#10;            new { Operation = MathOperationType.SubtractEnum, X = 10.0, Y = 3.0, Expected = 7.0 },&#10;            new { Operation = MathOperationType.MultiplyEnum, X = 4.0, Y = 3.0, Expected = 12.0 },&#10;            new { Operation = MathOperationType.DivideEnum, X = 20.0, Y = 4.0, Expected = 5.0 }&#10;        };&#10;&#10;        foreach (var operation in successfulOperations)&#10;        {&#10;            var mathRequest = new MathRequest&#10;            {&#10;                Operation = operation.Operation,&#10;                X = operation.X,&#10;                Y = operation.Y&#10;            };&#10;&#10;            var jsonContent = new StringContent(&#10;                JsonSerializer.Serialize(mathRequest),&#10;                Encoding.UTF8,&#10;                &quot;application/json&quot;);&#10;&#10;            var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            Assert.True(response.IsSuccessStatusCode, $&quot;{operation.Operation} operation should succeed&quot;);&#10;&#10;            var responseContent = await response.Content.ReadAsStringAsync();&#10;            var mathResponse = JsonSerializer.Deserialize&lt;MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;            {&#10;                PropertyNameCaseInsensitive = true&#10;            });&#10;&#10;            Assert.NotNull(mathResponse);&#10;            Assert.True(mathResponse.Success, $&quot;{operation.Operation} should return success&quot;);&#10;            Assert.Null(mathResponse.Error);&#10;            Assert.Equal(operation.Expected, mathResponse.Result!.Value, precision: 10);&#10;        }&#10;&#10;        // Step 4: Test divide by zero scenarios with authentication&#10;        var divideByZeroOperations = new[]&#10;        {&#10;            new { X = 10.0, Y = 0.0, Description = &quot;Positive number divided by zero&quot; },&#10;            new { X = -5.0, Y = 0.0, Description = &quot;Negative number divided by zero&quot; },&#10;            new { X = 0.0, Y = 0.0, Description = &quot;Zero divided by zero&quot; }&#10;        };&#10;&#10;        foreach (var operation in divideByZeroOperations)&#10;        {&#10;            var mathRequest = new MathRequest&#10;            {&#10;                Operation = MathOperationType.DivideEnum,&#10;                X = operation.X,&#10;                Y = operation.Y&#10;            };&#10;&#10;            var jsonContent = new StringContent(&#10;                JsonSerializer.Serialize(mathRequest),&#10;                Encoding.UTF8,&#10;                &quot;application/json&quot;);&#10;&#10;            var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            &#10;            // The response might be either a successful response with error details&#10;            // or a BadRequest, depending on how the API handles division by zero&#10;            var responseContent = await response.Content.ReadAsStringAsync();&#10;            var mathResponse = JsonSerializer.Deserialize&lt;MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;            {&#10;                PropertyNameCaseInsensitive = true&#10;            });&#10;&#10;            Assert.NotNull(mathResponse);&#10;            Assert.False(mathResponse.Success!.Value, $&quot;Divide by zero should return failure for {operation.Description}&quot;);&#10;            Assert.NotNull(mathResponse.Error);&#10;            Assert.Contains(&quot;division by zero&quot;, mathResponse.Error.ToLower(), StringComparison.InvariantCulture);&#10;        }&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;cache_test_user_1&quot;)]&#10;    [InlineData(&quot;cache_test_user_2&quot;)]&#10;    [InlineData(&quot;cache_test_user_3&quot;)]&#10;    public async Task CacheIntegration_RepeatedRequests_ShouldUseCaching(string username)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = username };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;&#10;        // Perform the same calculation multiple times to test caching&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.MultiplyEnum,&#10;            X = 7.0,&#10;            Y = 6.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // First request - should calculate and cache&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response1.IsSuccessStatusCode);&#10;        &#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result1);&#10;        Assert.True(result1.Success);&#10;        Assert.Equal(42.0, result1.Result!.Value);&#10;&#10;        // Second request - should use cache (same result, potentially faster)&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response2.IsSuccessStatusCode);&#10;        &#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result2);&#10;        Assert.True(result2.Success);&#10;        Assert.Equal(42.0, result2.Result!.Value);&#10;&#10;        // Results should be identical (demonstrating cache consistency)&#10;        Assert.Equal(result1.Result, result2.Result);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task TokenValidation_ExpiredToken_ShouldRejectRequests()&#10;    {&#10;        // This test would require a token with very short expiry&#10;        // For demonstration, we'll test with an invalid token instead&#10;        &#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Use an obviously invalid token&#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, &quot;invalid.token.that.should.fail.validation&quot;);&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.AddEnum,&#10;            X = 1.0,&#10;            Y = 1.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, response.StatusCode);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 100.0, 200.0, 300.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 100.0, 30.0, 70.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 12.0, 8.0, 96.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 144.0, 12.0, 12.0)]&#10;    public async Task AuthenticatedMathOperations_AllOperationTypes_ReturnCorrectResults(&#10;        MathOperationType operation, double x, double y, double expectedResult)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = $&quot;test_user_{operation}&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/auth/token&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode, $&quot;{operation} operation should succeed&quot;);&#10;        &#10;        var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result);&#10;        Assert.True(result.Success, $&quot;{operation} should return success&quot;);&#10;        Assert.Null(result.Error);&#10;        Assert.Equal(expectedResult, result.Result!.Value, precision: 10);&#10;    }&#10;}&#10;&#10;public class IntegrationTest1&#10;{&#10;    [Fact]&#10;    public async Task GetWebResourceRootReturnsOkStatusCode()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder&#10;                          .CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;&#10;        // To output logs to the xUnit.net ITestOutputHelper, &#10;        // consider adding a package from https://www.nuget.org/packages?q=xunit+logging&#10;&#10;        await using var app = await builder.BuildAsync();&#10;&#10;        await app.StartAsync();&#10;&#10;        // Act&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));&#10;        await app.ResourceNotifications.WaitForResourceHealthyAsync(&#10;                                                                    &quot;webfrontend&quot;,&#10;                                                                    cts.Token);&#10;&#10;        var response = await httpClient.GetAsync(&quot;/&quot;);&#10;&#10;        // Assert&#10;        Assert.Equal(HttpStatusCode.OK, response.StatusCode);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Net;&#10;using Aspire.Hosting.Testing;&#10;using IO.Swagger.Models.Math;&#10;using IO.Swagger.Models.Token;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using System.Net.Http.Headers;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using IO.Swagger.Models;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;/// &lt;summary&gt;&#10;/// Comprehensive end-to-end tests that validate the complete integration of:&#10;/// - Authentication Service (token validation)&#10;/// - Redis Service (caching)&#10;/// - Math API with divide by zero handling&#10;/// &lt;/summary&gt;&#10;public class ComprehensiveIntegrationTests&#10;{&#10;    [Fact]&#10;    public async Task CompleteWorkflow_AuthenticationAndMathOperations_WorksCorrectly()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder&#10;                          .CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;&#10;        // To output logs to the xUnit.net ITestOutputHelper, &#10;        // consider adding a package from https://www.nuget.org/packages?q=xunit+logging&#10;&#10;        await using var app = await builder.BuildAsync();&#10;&#10;        await app.StartAsync();&#10;&#10;        // Act&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;&#10;        // Step 1: Authenticate and get token&#10;        var tokenRequest = new TokenRequest { Username = &quot;integration_test_user&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        Assert.True(tokenResponse.IsSuccessStatusCode, &quot;Token generation should succeed&quot;);&#10;        &#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        Assert.NotNull(token);&#10;        Assert.NotNull(token.Token);&#10;&#10;        // Step 2: Set authorization header for subsequent requests&#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token.Token);&#10;&#10;        // Step 3: Test successful math operations (these should be cached)&#10;        var successfulOperations = new[]&#10;        {&#10;            new { Operation = MathOperationType.AddEnum, X = 10.0, Y = 5.0, Expected = 15.0 },&#10;            new { Operation = MathOperationType.SubtractEnum, X = 10.0, Y = 3.0, Expected = 7.0 },&#10;            new { Operation = MathOperationType.MultiplyEnum, X = 4.0, Y = 3.0, Expected = 12.0 },&#10;            new { Operation = MathOperationType.DivideEnum, X = 20.0, Y = 4.0, Expected = 5.0 }&#10;        };&#10;&#10;        foreach (var operation in successfulOperations)&#10;        {&#10;            var mathRequest = new MathRequest&#10;            {&#10;                Operation = operation.Operation,&#10;                X = operation.X,&#10;                Y = operation.Y&#10;            };&#10;&#10;            var jsonContent = new StringContent(&#10;                JsonSerializer.Serialize(mathRequest),&#10;                Encoding.UTF8,&#10;                &quot;application/json&quot;);&#10;&#10;            var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            Assert.True(response.IsSuccessStatusCode, $&quot;{operation.Operation} operation should succeed&quot;);&#10;&#10;            var responseContent = await response.Content.ReadAsStringAsync();&#10;            var mathResponse = JsonSerializer.Deserialize&lt;MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;            {&#10;                PropertyNameCaseInsensitive = true&#10;            });&#10;&#10;            Assert.NotNull(mathResponse);&#10;            Assert.True(mathResponse.Success, $&quot;{operation.Operation} should return success&quot;);&#10;            Assert.Null(mathResponse.Error);&#10;            Assert.Equal(operation.Expected, mathResponse.Result!.Value, precision: 10);&#10;        }&#10;&#10;        // Step 4: Test divide by zero scenarios with authentication&#10;        var divideByZeroOperations = new[]&#10;        {&#10;            new { X = 10.0, Y = 0.0, Description = &quot;Positive number divided by zero&quot; },&#10;            new { X = -5.0, Y = 0.0, Description = &quot;Negative number divided by zero&quot; },&#10;            new { X = 0.0, Y = 0.0, Description = &quot;Zero divided by zero&quot; }&#10;        };&#10;&#10;        foreach (var operation in divideByZeroOperations)&#10;        {&#10;            var mathRequest = new MathRequest&#10;            {&#10;                Operation = MathOperationType.DivideEnum,&#10;                X = operation.X,&#10;                Y = operation.Y&#10;            };&#10;&#10;            var jsonContent = new StringContent(&#10;                JsonSerializer.Serialize(mathRequest),&#10;                Encoding.UTF8,&#10;                &quot;application/json&quot;);&#10;&#10;            var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            &#10;            // The response might be either a successful response with error details&#10;            // or a BadRequest, depending on how the API handles division by zero&#10;            var responseContent = await response.Content.ReadAsStringAsync();&#10;            var mathResponse = JsonSerializer.Deserialize&lt;MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;            {&#10;                PropertyNameCaseInsensitive = true&#10;            });&#10;&#10;            Assert.NotNull(mathResponse);&#10;            Assert.False(mathResponse.Success!.Value, $&quot;Divide by zero should return failure for {operation.Description}&quot;);&#10;            Assert.NotNull(mathResponse.Error);&#10;            Assert.Contains(&quot;division by zero&quot;, mathResponse.Error.ToLower(), StringComparison.InvariantCulture);&#10;        }&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;cache_test_user_1&quot;)]&#10;    [InlineData(&quot;cache_test_user_2&quot;)]&#10;    [InlineData(&quot;cache_test_user_3&quot;)]&#10;    public async Task CacheIntegration_RepeatedRequests_ShouldUseCaching(string username)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = username };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;&#10;        // Perform the same calculation multiple times to test caching&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.MultiplyEnum,&#10;            X = 7.0,&#10;            Y = 6.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // First request - should calculate and cache&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response1.IsSuccessStatusCode);&#10;        &#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result1);&#10;        Assert.True(result1.Success);&#10;        Assert.Equal(42.0, result1.Result!.Value);&#10;&#10;        // Second request - should use cache (same result, potentially faster)&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response2.IsSuccessStatusCode);&#10;        &#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result2);&#10;        Assert.True(result2.Success);&#10;        Assert.Equal(42.0, result2.Result!.Value);&#10;&#10;        // Results should be identical (demonstrating cache consistency)&#10;        Assert.Equal(result1.Result, result2.Result);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task TokenValidation_ExpiredToken_ShouldRejectRequests()&#10;    {&#10;        // This test would require a token with very short expiry&#10;        // For demonstration, we'll test with an invalid token instead&#10;        &#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Use an obviously invalid token&#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, &quot;invalid.token.that.should.fail.validation&quot;);&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.AddEnum,&#10;            X = 1.0,&#10;            Y = 1.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, response.StatusCode);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 100.0, 200.0, 300.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 100.0, 30.0, 70.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 12.0, 8.0, 96.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 144.0, 12.0, 12.0)]&#10;    public async Task AuthenticatedMathOperations_AllOperationTypes_ReturnCorrectResults(&#10;        MathOperationType operation, double x, double y, double expectedResult)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = $&quot;test_user_{operation}&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode, $&quot;{operation} operation should succeed&quot;);&#10;        &#10;        var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result);&#10;        Assert.True(result.Success, $&quot;{operation} should return success&quot;);&#10;        Assert.Null(result.Error);&#10;        Assert.Equal(expectedResult, result.Result!.Value, precision: 10);&#10;    }&#10;}&#10;&#10;public class IntegrationTest1&#10;{&#10;    [Fact]&#10;    public async Task GetWebResourceRootReturnsOkStatusCode()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder&#10;                          .CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;&#10;        // To output logs to the xUnit.net ITestOutputHelper, &#10;        // consider adding a package from https://www.nuget.org/packages?q=xunit+logging&#10;&#10;        await using var app = await builder.BuildAsync();&#10;&#10;        await app.StartAsync();&#10;&#10;        // Act&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));&#10;        await app.ResourceNotifications.WaitForResourceHealthyAsync(&#10;                                                                    &quot;webfrontend&quot;,&#10;                                                                    cts.Token);&#10;&#10;        var response = await httpClient.GetAsync(&quot;/&quot;);&#10;&#10;        // Assert&#10;        Assert.Equal(HttpStatusCode.OK, response.StatusCode);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Tests/Integration/MockoonIntegrationTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Tests/Integration/MockoonIntegrationTests.cs" />
              <option name="originalContent" value="using Aspire.Hosting.Testing;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests.Integration;&#10;&#10;/// &lt;summary&gt;&#10;/// Integration tests for Mockoon service endpoints&#10;/// &lt;/summary&gt;&#10;public class MockoonIntegrationTests&#10;{&#10;    [Fact]&#10;    public async Task MockoonService_CallMetaAddEndpoint_ReturnsExpectedResult()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        // Act&#10;        using var httpClient = new HttpClient();&#10;        var response = await httpClient.GetAsync(&quot;http://localhost:3000/api/meta/add/5/3&quot;);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode, &quot;Mockoon endpoint should respond successfully&quot;);&#10;        var content = await response.Content.ReadAsStringAsync();&#10;        Assert.NotNull(content);&#10;        Assert.NotEmpty(content);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Aspire.Hosting.Testing;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests.Integration;&#10;&#10;/// &lt;summary&gt;&#10;/// Integration tests for Mockoon service endpoints&#10;/// &lt;/summary&gt;&#10;public class MockoonIntegrationTests&#10;{&#10;    [Fact]&#10;    public async Task MockoonService_CallMetaAddEndpoint_ReturnsExpectedResult()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        // Act&#10;        var httpClient = app.CreateHttpClient(&quot;mockoon&quot;);&#10;        var response = await httpClient.GetAsync(&quot;/api/meta/add/5/3&quot;);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode, &quot;Mockoon endpoint should respond successfully&quot;);&#10;        var content = await response.Content.ReadAsStringAsync();&#10;        Assert.NotNull(content);&#10;        Assert.NotEmpty(content);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Tests/MathApiIntegrationTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Tests/MathApiIntegrationTests.cs" />
              <option name="updatedContent" value="using Aspire.Hosting.Testing;&#10;using IO.Swagger.Models.Math;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;public class MathApiIntegrationTests&#10;{&#10;    [Theory]&#10;    [InlineData(10.0, 0.0)] // Basic divide by zero&#10;    [InlineData(-5.5, 0.0)] // Negative number divided by zero&#10;    [InlineData(0.0, 0.0)] // Zero divided by zero&#10;    [InlineData(double.MaxValue, 0.0)] // Large number divided by zero&#10;    public async Task MathApi_DivideByZero_ReturnsErrorResponse(double x, double y)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.DivideEnum,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode || response.StatusCode == System.Net.HttpStatusCode.BadRequest);&#10;        &#10;        var responseContent = await response.Content.ReadAsStringAsync();&#10;        var mathResponse = JsonSerializer.Deserialize&lt;IO.Swagger.Models.MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true&#10;        });&#10;&#10;        Assert.NotNull(mathResponse);&#10;        Assert.False(mathResponse.Success);&#10;        Assert.NotNull(mathResponse.Error);&#10;        Assert.Contains(&quot;division by zero&quot;, mathResponse.Error.ToLower());&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(10.0, 5.0, 2.0)] // Basic division&#10;    [InlineData(15.0, 3.0, 5.0)] // Another division&#10;    [InlineData(-10.0, 2.0, -5.0)] // Negative dividend&#10;    [InlineData(10.0, -2.0, -5.0)] // Negative divisor&#10;    public async Task MathApi_ValidDivision_ReturnsSuccessResponse(double x, double y, double expectedResult)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.DivideEnum,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode);&#10;        &#10;        var responseContent = await response.Content.ReadAsStringAsync();&#10;        var mathResponse = JsonSerializer.Deserialize&lt;IO.Swagger.Models.MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true&#10;        });&#10;&#10;        Assert.NotNull(mathResponse);&#10;        Assert.True(mathResponse.Success);&#10;        Assert.Null(mathResponse.Error);&#10;        Assert.NotNull(mathResponse.Result);&#10;        Assert.Equal(expectedResult, mathResponse.Result.Value, precision: 10);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 10.0, 5.0, 15.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 10.0, 5.0, 5.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 10.0, 5.0, 50.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 10.0, 5.0, 2.0)]&#10;    public async Task MathApi_AllOperations_ReturnExpectedResults(MathOperationType operation, double x, double y, double expectedResult)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode);&#10;        &#10;        var responseContent = await response.Content.ReadAsStringAsync();&#10;        var mathResponse = JsonSerializer.Deserialize&lt;IO.Swagger.Models.MathResponse&gt;(responseContent, new JsonSerializerOptions&#10;        {&#10;            PropertyNameCaseInsensitive = true&#10;        });&#10;&#10;        Assert.NotNull(mathResponse);&#10;        Assert.True(mathResponse.Success);&#10;        Assert.Null(mathResponse.Error);&#10;        Assert.NotNull(mathResponse.Result);&#10;        Assert.Equal(expectedResult, mathResponse.Result.Value, precision: 10);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(null, 5.0)]&#10;    [InlineData(10.0, null)]&#10;    [InlineData(null, null)]&#10;    public async Task MathApi_NullValues_ReturnsBadRequest(double? x, double? y)&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.AddEnum,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.BadRequest, response.StatusCode);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task MathApi_InvalidOperation_ReturnsBadRequest()&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = null,&#10;            X = 10.0,&#10;            Y = 5.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.BadRequest, response.StatusCode);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task MathApi_EmptyRequest_ReturnsBadRequest()&#10;    {&#10;        // Arrange&#10;        var appHost = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await appHost.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;        &#10;        var jsonContent = new StringContent(&#10;            &quot;{}&quot;,&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;&#10;        // Assert&#10;        Assert.Equal(System.Net.HttpStatusCode.BadRequest, response.StatusCode);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Tests/RedisServiceTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Tests/RedisServiceTests.cs" />
              <option name="originalContent" value="using Aspire.Hosting.Testing;&#10;using IO.Swagger.Models.Math;&#10;using IO.Swagger.Models.Token;&#10;using IO.Swagger.Services;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using System.Net.Http.Headers;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using IO.Swagger.Models;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;public class RedisServiceTests&#10;{&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 10.5, 5.5)]&#10;    [InlineData(MathOperationType.SubtractEnum, 20.0, 8.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 3.5, 4.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 15.0, 3.0)]&#10;    public async Task RedisCaching_MathOperations_CachesAndRetrievesCorrectly(MathOperationType operation, double x, double y)&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate first&#10;        var tokenRequest = new TokenRequest { Username = $&quot;redis_test_user_{operation}&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)operation).ToString());&#10;&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - First request (should calculate and cache)&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response1.IsSuccessStatusCode);&#10;        &#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result1);&#10;        Assert.True(result1.Success);&#10;        Assert.NotNull(result1.Result);&#10;&#10;        // Act - Second request (should retrieve from cache)&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response2.IsSuccessStatusCode);&#10;        &#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result2);&#10;        Assert.True(result2.Success);&#10;        Assert.NotNull(result2.Result);&#10;&#10;        // Assert - Both results should be identical (demonstrating cache consistency)&#10;        Assert.Equal(result1.Result, result2.Result);&#10;        Assert.Equal(result1.Success, result2.Success);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 1.0, 2.0, 3.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 5.0, 3.0, 2.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 2.0, 4.0, 8.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 10.0, 2.0, 5.0)]&#10;    public async Task RedisCaching_DifferentOperations_CachesIndependently(MathOperationType operation, double x, double y, double expectedResult)&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = $&quot;cache_independent_test_{operation}&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;,((int)operation).ToString());&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        &#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode);&#10;        var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result);&#10;        Assert.True(result.Success);&#10;        Assert.Equal(expectedResult, result.Result!.Value, precision: 10);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task RedisCaching_SameOperationDifferentValues_CachesSeparately()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = &quot;cache_separate_test_user&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)MathOperationType.AddEnum).ToString());&#10;&#10;        // Test different calculations with same operation&#10;        var calculations = new[]&#10;        {&#10;            new { X = 10.0, Y = 5.0, Expected = 15.0 },&#10;            new { X = 20.0, Y = 3.0, Expected = 23.0 },&#10;            new { X = 7.0, Y = 8.0, Expected = 15.0 }&#10;        };&#10;&#10;        foreach (var calc in calculations)&#10;        {&#10;            var mathRequest = new MathRequest&#10;            {&#10;                Operation = MathOperationType.AddEnum,&#10;                X = calc.X,&#10;                Y = calc.Y&#10;            };&#10;&#10;            var jsonContent = new StringContent(&#10;                JsonSerializer.Serialize(mathRequest),&#10;                Encoding.UTF8,&#10;                &quot;application/json&quot;);&#10;&#10;            // Act&#10;            var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            &#10;            // Assert&#10;            Assert.True(response.IsSuccessStatusCode);&#10;            var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;            Assert.NotNull(result);&#10;            Assert.True(result.Success);&#10;            Assert.Equal(calc.Expected, result.Result!.Value, precision: 10);&#10;        }&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(0.0, 0.0)]&#10;    [InlineData(-5.5, 2.5)]&#10;    [InlineData(999999.99, -0.01)]&#10;    public async Task RedisCaching_EdgeCaseValues_HandlesCorrectly(double x, double y)&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = &quot;edge_case_test_user&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)MathOperationType.MultiplyEnum).ToString());&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.MultiplyEnum,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - First request&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response1.IsSuccessStatusCode);&#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        // Act - Second request (should use cache)&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response2.IsSuccessStatusCode);&#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        // Assert&#10;        Assert.NotNull(result1);&#10;        Assert.NotNull(result2);&#10;        Assert.True(result1.Success);&#10;        Assert.True(result2.Success);&#10;        Assert.Equal(result1.Result, result2.Result);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task RedisCaching_MultipleUsers_CachesIndependently()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var users = new[] { &quot;user1&quot;, &quot;user2&quot;, &quot;user3&quot; };&#10;        var httpClients = new Dictionary&lt;string, HttpClient&gt;();&#10;&#10;        // Authenticate all users&#10;        foreach (var user in users)&#10;        {&#10;            var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;            var tokenRequest = new TokenRequest { Username = user };&#10;            var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;            var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;            &#10;            httpClient.DefaultRequestHeaders.Authorization = &#10;                new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;            httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)MathOperationType.AddEnum).ToString());&#10;&#10;            httpClients[user] = httpClient;&#10;        }&#10;&#10;        // Same calculation for all users&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.AddEnum,&#10;            X = 15.0,&#10;            Y = 25.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - All users perform the same calculation&#10;        var results = new Dictionary&lt;string, MathResponse&gt;();&#10;        foreach (var user in users)&#10;        {&#10;            var response = await httpClients[user].PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            Assert.True(response.IsSuccessStatusCode);&#10;            var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;            results[user] = result!;&#10;        }&#10;&#10;        // Assert - All results should be identical (cache working correctly across users)&#10;        var expectedResult = 40.0;&#10;        foreach (var user in users)&#10;        {&#10;            Assert.NotNull(results[user]);&#10;            Assert.True(results[user].Success);&#10;            Assert.Equal(expectedResult, results[user].Result!.Value, precision: 10);&#10;        }&#10;    }&#10;&#10;    [Fact]&#10;    public async Task RedisCaching_DivideByZero_DoesNotCacheErrors()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = &quot;divide_by_zero_cache_test&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.DivideEnum,&#10;            X = 10.0,&#10;            Y = 0.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - Multiple requests for divide by zero&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        // Assert - Both should return error (errors typically shouldn't be cached)&#10;        Assert.NotNull(result1);&#10;        Assert.NotNull(result2);&#10;        Assert.False(result1.Success!.Value);&#10;        Assert.False(result2.Success!.Value);&#10;        Assert.NotNull(result1.Error);&#10;        Assert.NotNull(result2.Error);&#10;        Assert.Contains(&quot;division by zero&quot;, result1.Error.ToLower());&#10;        Assert.Contains(&quot;division by zero&quot;, result2.Error.ToLower());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Aspire.Hosting.Testing;&#10;using IO.Swagger.Models.Math;&#10;using IO.Swagger.Models.Token;&#10;using IO.Swagger.Services;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using System.Net.Http.Headers;&#10;using System.Net.Http.Json;&#10;using System.Text;&#10;using System.Text.Json;&#10;using IO.Swagger.Models;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;public class RedisServiceTests&#10;{&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 10.5, 5.5)]&#10;    [InlineData(MathOperationType.SubtractEnum, 20.0, 8.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 3.5, 4.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 15.0, 3.0)]&#10;    public async Task RedisCaching_MathOperations_CachesAndRetrievesCorrectly(MathOperationType operation, double x, double y)&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate first&#10;        var tokenRequest = new TokenRequest { Username = $&quot;redis_test_user_{operation}&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)operation).ToString());&#10;&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - First request (should calculate and cache)&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response1.IsSuccessStatusCode);&#10;        &#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result1);&#10;        Assert.True(result1.Success);&#10;        Assert.NotNull(result1.Result);&#10;&#10;        // Act - Second request (should retrieve from cache)&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response2.IsSuccessStatusCode);&#10;        &#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result2);&#10;        Assert.True(result2.Success);&#10;        Assert.NotNull(result2.Result);&#10;&#10;        // Assert - Both results should be identical (demonstrating cache consistency)&#10;        Assert.Equal(result1.Result, result2.Result);&#10;        Assert.Equal(result1.Success, result2.Success);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 1.0, 2.0, 3.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 5.0, 3.0, 2.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 2.0, 4.0, 8.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 10.0, 2.0, 5.0)]&#10;    public async Task RedisCaching_DifferentOperations_CachesIndependently(MathOperationType operation, double x, double y, double expectedResult)&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = $&quot;cache_independent_test_{operation}&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;,((int)operation).ToString());&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = operation,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act&#10;        var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        &#10;        // Assert&#10;        Assert.True(response.IsSuccessStatusCode);&#10;        var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;        Assert.NotNull(result);&#10;        Assert.True(result.Success);&#10;        Assert.Equal(expectedResult, result.Result!.Value, precision: 10);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task RedisCaching_SameOperationDifferentValues_CachesSeparately()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = &quot;cache_separate_test_user&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)MathOperationType.AddEnum).ToString());&#10;&#10;        // Test different calculations with same operation&#10;        var calculations = new[]&#10;        {&#10;            new { X = 10.0, Y = 5.0, Expected = 15.0 },&#10;            new { X = 20.0, Y = 3.0, Expected = 23.0 },&#10;            new { X = 7.0, Y = 8.0, Expected = 15.0 }&#10;        };&#10;&#10;        foreach (var calc in calculations)&#10;        {&#10;            var mathRequest = new MathRequest&#10;            {&#10;                Operation = MathOperationType.AddEnum,&#10;                X = calc.X,&#10;                Y = calc.Y&#10;            };&#10;&#10;            var jsonContent = new StringContent(&#10;                JsonSerializer.Serialize(mathRequest),&#10;                Encoding.UTF8,&#10;                &quot;application/json&quot;);&#10;&#10;            // Act&#10;            var response = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            &#10;            // Assert&#10;            Assert.True(response.IsSuccessStatusCode);&#10;            var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;            Assert.NotNull(result);&#10;            Assert.True(result.Success);&#10;            Assert.Equal(calc.Expected, result.Result!.Value, precision: 10);&#10;        }&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(0.0, 0.0)]&#10;    [InlineData(-5.5, 2.5)]&#10;    [InlineData(999999.99, -0.01)]&#10;    public async Task RedisCaching_EdgeCaseValues_HandlesCorrectly(double x, double y)&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = &quot;edge_case_test_user&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)MathOperationType.MultiplyEnum).ToString());&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.MultiplyEnum,&#10;            X = x,&#10;            Y = y&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - First request&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response1.IsSuccessStatusCode);&#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        // Act - Second request (should use cache)&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        Assert.True(response2.IsSuccessStatusCode);&#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        // Assert&#10;        Assert.NotNull(result1);&#10;        Assert.NotNull(result2);&#10;        Assert.True(result1.Success);&#10;        Assert.True(result2.Success);&#10;        Assert.Equal(result1.Result, result2.Result);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task RedisCaching_MultipleUsers_CachesIndependently()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var users = new[] { &quot;user1&quot;, &quot;user2&quot;, &quot;user3&quot; };&#10;        var httpClients = new Dictionary&lt;string, HttpClient&gt;();&#10;&#10;        // Authenticate all users&#10;        foreach (var user in users)&#10;        {&#10;            var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;            var tokenRequest = new TokenRequest { Username = user };&#10;            var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;            var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;            &#10;            httpClient.DefaultRequestHeaders.Authorization = &#10;                new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;            httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)MathOperationType.AddEnum).ToString());&#10;&#10;            httpClients[user] = httpClient;&#10;        }&#10;&#10;        // Same calculation for all users&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.AddEnum,&#10;            X = 15.0,&#10;            Y = 25.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - All users perform the same calculation&#10;        var results = new Dictionary&lt;string, MathResponse&gt;();&#10;        foreach (var user in users)&#10;        {&#10;            var response = await httpClients[user].PostAsync(&quot;/api/math&quot;, jsonContent);&#10;            Assert.True(response.IsSuccessStatusCode);&#10;            var result = await response.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;            results[user] = result!;&#10;        }&#10;&#10;        // Assert - All results should be identical (cache working correctly across users)&#10;        var expectedResult = 40.0;&#10;        foreach (var user in users)&#10;        {&#10;            Assert.NotNull(results[user]);&#10;            Assert.True(results[user].Success);&#10;            Assert.Equal(expectedResult, results[user].Result!.Value, precision: 10);&#10;        }&#10;    }&#10;&#10;    [Fact]&#10;    public async Task RedisCaching_DivideByZero_DoesNotCacheErrors()&#10;    {&#10;        // Arrange&#10;        var builder = await DistributedApplicationTestingBuilder.CreateAsync&lt;Projects.IO_Swagger_AppHost&gt;();&#10;        builder.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;&#10;        {&#10;            clientBuilder.AddStandardResilienceHandler();&#10;        });&#10;        await using var app = await builder.BuildAsync();&#10;        await app.StartAsync();&#10;&#10;        var httpClient = app.CreateHttpClient(&quot;io-swagger&quot;);&#10;&#10;        // Authenticate&#10;        var tokenRequest = new TokenRequest { Username = &quot;divide_by_zero_cache_test&quot; };&#10;        var tokenResponse = await httpClient.PostAsJsonAsync(&quot;/api/token/generate&quot;, tokenRequest);&#10;        var token = await tokenResponse.Content.ReadFromJsonAsync&lt;TokenResponse&gt;();&#10;        &#10;        httpClient.DefaultRequestHeaders.Authorization = &#10;            new AuthenticationHeaderValue(&quot;Bearer&quot;, token!.Token);&#10;        httpClient.DefaultRequestHeaders.Add(&quot;X-ArithmeticOp-ID&quot;, ((int)MathOperationType.DivideEnum).ToString());&#10;&#10;        var mathRequest = new MathRequest&#10;        {&#10;            Operation = MathOperationType.DivideEnum,&#10;            X = 10.0,&#10;            Y = 0.0&#10;        };&#10;&#10;        var jsonContent = new StringContent(&#10;            JsonSerializer.Serialize(mathRequest),&#10;            Encoding.UTF8,&#10;            &quot;application/json&quot;);&#10;&#10;        // Act - Multiple requests for divide by zero&#10;        var response1 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        var result1 = await response1.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        var response2 = await httpClient.PostAsync(&quot;/api/math&quot;, jsonContent);&#10;        var result2 = await response2.Content.ReadFromJsonAsync&lt;MathResponse&gt;();&#10;&#10;        // Assert - Both should return error (errors typically shouldn't be cached)&#10;        Assert.NotNull(result1);&#10;        Assert.NotNull(result2);&#10;        Assert.False(result1.Success!.Value);&#10;        Assert.False(result2.Success!.Value);&#10;        Assert.NotNull(result1.Error);&#10;        Assert.NotNull(result2.Error);&#10;        Assert.Contains(&quot;division by zero&quot;, result1.Error.ToLower());&#10;        Assert.Contains(&quot;division by zero&quot;, result2.Error.ToLower());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger.Tests/RedisServiceUnitTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger.Tests/RedisServiceUnitTests.cs" />
              <option name="updatedContent" value="using IO.Swagger.Models.Math;&#10;using IO.Swagger.Services;&#10;using StackExchange.Redis;&#10;using Xunit;&#10;&#10;namespace IO.Swagger.Tests;&#10;&#10;public class RedisServiceUnitTests : IDisposable&#10;{&#10;    private readonly IConnectionMultiplexer _connectionMultiplexer;&#10;    private readonly RedisService _redisService;&#10;    private readonly IDatabase _database;&#10;&#10;    public RedisServiceUnitTests()&#10;    {&#10;        // Connect to local Redis instance&#10;        _connectionMultiplexer = ConnectionMultiplexer.Connect(&quot;localhost:6379&quot;);&#10;        _redisService = new RedisService(_connectionMultiplexer);&#10;        _database = _connectionMultiplexer.GetDatabase();&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 10.5, 5.5, 16.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 20.0, 8.0, 12.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 3.5, 4.0, 14.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 15.0, 3.0, 5.0)]&#10;    public async Task SetMathDataAsync_ValidData_StoresCorrectlyInRedis(MathOperationType operation, double x, double y, double result)&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = operation, X = x, Y = y };&#10;        var ttl = TimeSpan.FromMinutes(30);&#10;        var expectedKey = $&quot;{operation}:{x}:{y}&quot;;&#10;&#10;        // Clean up any existing data&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;&#10;        // Act&#10;        await _redisService.SetMathDataAsync(request, result, ttl);&#10;&#10;        // Assert&#10;        var storedValue = await _database.StringGetAsync(expectedKey);&#10;        Assert.True(storedValue.HasValue);&#10;        Assert.True(double.TryParse(storedValue, out var parsedValue));&#10;        Assert.Equal(result, parsedValue, precision: 10);&#10;&#10;        // Verify TTL is set&#10;        var expiry = await _database.KeyTimeToLiveAsync(expectedKey);&#10;        Assert.True(expiry.HasValue);&#10;        Assert.True(expiry.Value.TotalMinutes &gt; 29); // Should be close to 30 minutes&#10;&#10;        // Clean up&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 10.5, 5.5, 16.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 20.0, 8.0, 12.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 3.5, 4.0, 14.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 15.0, 3.0, 5.0)]&#10;    public async Task GetMathDataAsync_ExistingKey_ReturnsExpectedValue(MathOperationType operation, double x, double y, double expectedResult)&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = operation, X = x, Y = y };&#10;        var expectedKey = $&quot;{operation}:{x}:{y}&quot;;&#10;&#10;        // Pre-populate Redis with test data&#10;        await _database.StringSetAsync(expectedKey, expectedResult.ToString());&#10;&#10;        // Act&#10;        var result = await _redisService.GetMathDataAsync(request);&#10;&#10;        // Assert&#10;        Assert.NotNull(result);&#10;        Assert.Equal(expectedResult, result.Value, precision: 10);&#10;&#10;        // Clean up&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 1.0, 2.0)]&#10;    [InlineData(MathOperationType.SubtractEnum, 5.0, 3.0)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 2.0, 4.0)]&#10;    [InlineData(MathOperationType.DivideEnum, 10.0, 2.0)]&#10;    public async Task GetMathDataAsync_NonExistingKey_ReturnsNull(MathOperationType operation, double x, double y)&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = operation, X = x, Y = y };&#10;        var expectedKey = $&quot;{operation}:{x}:{y}&quot;;&#10;&#10;        // Ensure key doesn't exist&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;&#10;        // Act&#10;        var result = await _redisService.GetMathDataAsync(request);&#10;&#10;        // Assert&#10;        Assert.Null(result);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 1.0, 2.0, true)]&#10;    [InlineData(MathOperationType.SubtractEnum, 5.0, 3.0, false)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 2.0, 4.0, true)]&#10;    [InlineData(MathOperationType.DivideEnum, 10.0, 2.0, false)]&#10;    public async Task IsMathKeyExistsAsync_VariousKeys_ReturnsExpectedResult(MathOperationType operation, double x, double y, bool shouldExist)&#10;    {&#10;        // Arrange&#10;        var expectedKey = $&quot;{operation}:{x}:{y}&quot;;&#10;&#10;        if (shouldExist)&#10;        {&#10;            // Create the key&#10;            await _database.StringSetAsync(expectedKey, &quot;42&quot;);&#10;        }&#10;        else&#10;        {&#10;            // Ensure key doesn't exist&#10;            await _database.KeyDeleteAsync(expectedKey);&#10;        }&#10;&#10;        // Act&#10;        var result = await _redisService.IsMathKeyExistsAsync(expectedKey);&#10;&#10;        // Assert&#10;        Assert.Equal(shouldExist, result);&#10;&#10;        // Clean up&#10;        if (shouldExist)&#10;        {&#10;            await _database.KeyDeleteAsync(expectedKey);&#10;        }&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(&quot;invalid_value&quot;)]&#10;    [InlineData(&quot;not_a_number&quot;)]&#10;    [InlineData(&quot;&quot;)]&#10;    [InlineData(&quot;abc123&quot;)]&#10;    public async Task GetMathDataAsync_InvalidRedisValue_ReturnsNull(string invalidValue)&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = MathOperationType.AddEnum, X = 1.0, Y = 2.0 };&#10;        var expectedKey = $&quot;{MathOperationType.AddEnum}:1:2&quot;;&#10;&#10;        // Store invalid value in Redis&#10;        await _database.StringSetAsync(expectedKey, invalidValue);&#10;&#10;        // Act&#10;        var result = await _redisService.GetMathDataAsync(request);&#10;&#10;        // Assert&#10;        Assert.Null(result);&#10;&#10;        // Clean up&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(MathOperationType.AddEnum, 0.0, 0.0)]&#10;    [InlineData(MathOperationType.DivideEnum, -5.5, 2.5)]&#10;    [InlineData(MathOperationType.MultiplyEnum, 999999.99, -0.01)]&#10;    [InlineData(MathOperationType.SubtractEnum, double.MaxValue, double.MinValue)]&#10;    public async Task SetAndGetMathDataAsync_EdgeCaseValues_HandlesCorrectly(MathOperationType operation, double x, double y)&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = operation, X = x, Y = y };&#10;        var expectedResult = 42.123456789; // Test value with high precision&#10;        var ttl = TimeSpan.FromMinutes(5);&#10;        var expectedKey = $&quot;{operation}:{x}:{y}&quot;;&#10;&#10;        // Clean up any existing data&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;&#10;        // Act - Set data&#10;        await _redisService.SetMathDataAsync(request, expectedResult, ttl);&#10;&#10;        // Act - Get data&#10;        var result = await _redisService.GetMathDataAsync(request);&#10;&#10;        // Assert&#10;        Assert.NotNull(result);&#10;        Assert.Equal(expectedResult, result.Value, precision: 10);&#10;&#10;        // Clean up&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;    }&#10;&#10;    [Theory]&#10;    [InlineData(1)] // 1 second&#10;    [InlineData(60)] // 1 minute  &#10;    [InlineData(3600)] // 1 hour&#10;    [InlineData(86400)] // 1 day&#10;    public async Task SetMathDataAsync_VariousTTL_SetsCorrectExpiration(int seconds)&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = MathOperationType.AddEnum, X = 1.0, Y = 2.0 };&#10;        var result = 3.0;&#10;        var ttl = TimeSpan.FromSeconds(seconds);&#10;        var expectedKey = $&quot;{MathOperationType.AddEnum}:1:2&quot;;&#10;&#10;        // Clean up any existing data&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;&#10;        // Act&#10;        await _redisService.SetMathDataAsync(request, result, ttl);&#10;&#10;        // Assert&#10;        var actualTtl = await _database.KeyTimeToLiveAsync(expectedKey);&#10;        Assert.True(actualTtl.HasValue);&#10;        &#10;        // Allow for small variance due to execution time&#10;        var expectedSeconds = seconds;&#10;        var actualSeconds = (int)actualTtl.Value.TotalSeconds;&#10;        Assert.True(Math.Abs(expectedSeconds - actualSeconds) &lt;= 2, &#10;            $&quot;Expected TTL around {expectedSeconds} seconds, but got {actualSeconds} seconds&quot;);&#10;&#10;        // Clean up&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task SetMathDataAsync_OverwriteExistingKey_UpdatesValue()&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = MathOperationType.AddEnum, X = 5.0, Y = 3.0 };&#10;        var initialResult = 8.0;&#10;        var updatedResult = 15.0;&#10;        var ttl = TimeSpan.FromMinutes(10);&#10;        var expectedKey = $&quot;{MathOperationType.AddEnum}:5:3&quot;;&#10;&#10;        // Clean up any existing data&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;&#10;        // Act - Set initial value&#10;        await _redisService.SetMathDataAsync(request, initialResult, ttl);&#10;        var firstResult = await _redisService.GetMathDataAsync(request);&#10;&#10;        // Act - Overwrite with new value&#10;        await _redisService.SetMathDataAsync(request, updatedResult, ttl);&#10;        var secondResult = await _redisService.GetMathDataAsync(request);&#10;&#10;        // Assert&#10;        Assert.NotNull(firstResult);&#10;        Assert.Equal(initialResult, firstResult.Value);&#10;        &#10;        Assert.NotNull(secondResult);&#10;        Assert.Equal(updatedResult, secondResult.Value);&#10;        Assert.NotEqual(firstResult.Value, secondResult.Value);&#10;&#10;        // Clean up&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task GetMathDataAsync_KeyWithoutTTL_ReturnsValue()&#10;    {&#10;        // Arrange&#10;        var request = new MathRequest { Operation = MathOperationType.MultiplyEnum, X = 6.0, Y = 7.0 };&#10;        var expectedResult = 42.0;&#10;        var expectedKey = $&quot;{MathOperationType.MultiplyEnum}:6:7&quot;;&#10;&#10;        // Store value without TTL (persistent key)&#10;        await _database.StringSetAsync(expectedKey, expectedResult.ToString());&#10;&#10;        // Act&#10;        var result = await _redisService.GetMathDataAsync(request);&#10;&#10;        // Assert&#10;        Assert.NotNull(result);&#10;        Assert.Equal(expectedResult, result.Value);&#10;&#10;        // Verify no TTL is set&#10;        var ttl = await _database.KeyTimeToLiveAsync(expectedKey);&#10;        Assert.False(ttl.HasValue); // Persistent key should have no TTL&#10;&#10;        // Clean up&#10;        await _database.KeyDeleteAsync(expectedKey);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task RedisKeyFormat_DifferentOperations_GenerateUniqueKeys()&#10;    {&#10;        // Arrange&#10;        var operations = new[]&#10;        {&#10;            (MathOperationType.AddEnum, 1.0, 2.0, 3.0),&#10;            (MathOperationType.SubtractEnum, 1.0, 2.0, -1.0),&#10;            (MathOperationType.MultiplyEnum, 1.0, 2.0, 2.0),&#10;            (MathOperationType.DivideEnum, 1.0, 2.0, 0.5)&#10;        };&#10;&#10;        var keys = new List&lt;string&gt;();&#10;&#10;        try&#10;        {&#10;            // Act - Store all operations&#10;            foreach (var (operation, x, y, result) in operations)&#10;            {&#10;                var request = new MathRequest { Operation = operation, X = x, Y = y };&#10;                var key = $&quot;{operation}:{x}:{y}&quot;;&#10;                keys.Add(key);&#10;&#10;                await _redisService.SetMathDataAsync(request, result, TimeSpan.FromMinutes(1));&#10;            }&#10;&#10;            // Assert - All keys should be unique and contain correct values&#10;            Assert.Equal(4, keys.Distinct().Count()); // All keys should be unique&#10;&#10;            foreach (var (operation, x, y, expectedResult) in operations)&#10;            {&#10;                var request = new MathRequest { Operation = operation, X = x, Y = y };&#10;                var actualResult = await _redisService.GetMathDataAsync(request);&#10;                &#10;                Assert.NotNull(actualResult);&#10;                Assert.Equal(expectedResult, actualResult.Value, precision: 10);&#10;            }&#10;        }&#10;        finally&#10;        {&#10;            // Clean up all keys&#10;            foreach (var key in keys)&#10;            {&#10;                await _database.KeyDeleteAsync(key);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void Dispose()&#10;    {&#10;        _connectionMultiplexer?.Dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Extensions/CustomOutputCachePolicy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Extensions/CustomOutputCachePolicy.cs" />
              <option name="originalContent" value="using System;&#10;using System.IO;&#10;using IO.Swagger.Models.Math;&#10;using IO.Swagger.Services;&#10;using Microsoft.AspNetCore.OutputCaching;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text.Json;&#10;using System.Threading;&#10;using System.Threading.Tasks;&#10;using IO.Swagger.Models;&#10;using Microsoft.AspNetCore.Http;&#10;&#10;namespace IO.Swagger.Extensions&#10;{&#10;    public class CustomOutputCachePolicy : IOutputCachePolicy&#10;    {&#10;        private readonly RadisService _redisService;&#10;        private readonly ILogger&lt;CustomOutputCachePolicy&gt; _logger;&#10;&#10;        public CustomOutputCachePolicy(RadisService redisService, ILogger&lt;CustomOutputCachePolicy&gt; logger)&#10;        {&#10;            _redisService = redisService;&#10;            _logger = logger;&#10;        }&#10;&#10;        public async ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation)&#10;        {&#10;            var request = context.HttpContext.Request;&#10;            &#10;            // Only cache POST requests to /api/math&#10;            if (request.Method == &quot;POST&quot; &amp;&amp; request.Path.StartsWithSegments(&quot;/api/math&quot;))&#10;            {&#10;                try&#10;                {&#10;                    // Read the request body to extract MathRequest&#10;                    request.EnableBuffering();&#10;                    request.Body.Position = 0;&#10;                    &#10;                    using var reader = new StreamReader(request.Body, leaveOpen: true);&#10;                    var body = await reader.ReadToEndAsync();&#10;                    request.Body.Position = 0;&#10;                    &#10;                    var mathRequest = JsonSerializer.Deserialize&lt;MathRequest&gt;(body, new JsonSerializerOptions&#10;                    {&#10;                        PropertyNameCaseInsensitive = true&#10;                    });&#10;                    &#10;                    if (mathRequest != null)&#10;                    {&#10;                        var cacheKey = $&quot;math:{mathRequest.Operation}:{mathRequest.X}:{mathRequest.Y}&quot;;&#10;                        &#10;                        // Check if we already have this calculation in Redis&#10;                        var cachedResult = await _redisService.GetMathDataAsync(cacheKey);&#10;                        if (cachedResult.HasValue)&#10;                        {&#10;                            _logger.LogInformation(&quot;Cache hit for key: {CacheKey}&quot;, cacheKey);&#10;                            &#10;                            // Create response from cached data&#10;                            var response = new MathResponse&#10;                            {&#10;                                Result = cachedResult.Value,&#10;                                Success = true&#10;                            };&#10;                            &#10;                            context.HttpContext.Response.StatusCode = 200;&#10;                            context.HttpContext.Response.ContentType = &quot;application/json&quot;;&#10;                            await context.HttpContext.Response.WriteAsync(&#10;                                JsonSerializer.Serialize(response, new JsonSerializerOptions &#10;                                { &#10;                                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase &#10;                                }));&#10;                            &#10;                            context.ResponseCached = true;&#10;                            return;&#10;                        }&#10;                        &#10;                        _logger.LogInformation(&quot;Cache miss for key: {CacheKey}&quot;, cacheKey);&#10;                        &#10;                        // Store the cache key for later use in response caching&#10;                        context.HttpContext.Items[&quot;CacheKey&quot;] = cacheKey;&#10;                        context.HttpContext.Items[&quot;MathRequest&quot;] = mathRequest;&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    _logger.LogWarning(ex, &quot;Failed to process cache request for math endpoint&quot;);&#10;                }&#10;            }&#10;            &#10;            // Allow request to proceed&#10;            context.AllowCacheLookup = true;&#10;            context.AllowCacheStorage = true;&#10;        }&#10;&#10;        public ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation)&#10;        {&#10;            // Custom cache serving is handled in CacheRequestAsync&#10;            return ValueTask.CompletedTask;&#10;        }&#10;&#10;        public async ValueTask ServeFromOriginAsync(OutputCacheContext context, CancellationToken cancellation)&#10;        {&#10;            // Store the response in Redis after it's generated&#10;            if (context.HttpContext.Items.TryGetValue(&quot;CacheKey&quot;, out var cacheKeyObj) &amp;&amp;&#10;                context.HttpContext.Items.TryGetValue(&quot;MathRequest&quot;, out var mathRequestObj) &amp;&amp;&#10;                cacheKeyObj is string cacheKey &amp;&amp;&#10;                mathRequestObj is MathRequest mathRequest)&#10;            {&#10;                try&#10;                {&#10;                    // Capture the response&#10;                    var originalBody = context.HttpContext.Response.Body;&#10;                    using var responseBody = new MemoryStream();&#10;                    context.HttpContext.Response.Body = responseBody;&#10;                    &#10;                    // Let the request complete&#10;                    await context.Next(context.HttpContext);&#10;                    &#10;                    // Read the response&#10;                    responseBody.Position = 0;&#10;                    var responseContent = await new StreamReader(responseBody).ReadToEndAsync();&#10;                    &#10;                    // Parse and cache the result&#10;                    if (!string.IsNullOrEmpty(responseContent))&#10;                    {&#10;                        var mathResponse = JsonSerializer.Deserialize&lt;MathResponse&gt;(responseContent, &#10;                            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });&#10;                        &#10;                        if (mathResponse?.Success == true)&#10;                        {&#10;                            await _redisService.SetMathDataAsync(mathRequest, mathResponse.Result, TimeSpan.FromSeconds(30));&#10;                            _logger.LogInformation(&quot;Cached result for key: {CacheKey}, Result: {Result}&quot;, cacheKey, mathResponse.Result);&#10;                        }&#10;                    }&#10;                    &#10;                    // Write response back to original stream&#10;                    responseBody.Position = 0;&#10;                    await responseBody.CopyToAsync(originalBody);&#10;                    context.HttpContext.Response.Body = originalBody;&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    _logger.LogWarning(ex, &quot;Failed to cache response for key: {CacheKey}&quot;, cacheKey);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Standard request processing&#10;                await context.Next(context.HttpContext);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.IO;&#10;using IO.Swagger.Models.Math;&#10;using IO.Swagger.Services;&#10;using Microsoft.AspNetCore.OutputCaching;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text.Json;&#10;using Microsoft.AspNetCore.Http;&#10;&#10;namespace IO.Swagger.Extensions&#10;{&#10;    public class CustomOutputCachePolicy : IOutputCachePolicy&#10;    {&#10;        private readonly RadisService _redisService;&#10;        private readonly ILogger&lt;CustomOutputCachePolicy&gt; _logger;&#10;&#10;        public CustomOutputCachePolicy(RadisService redisService, ILogger&lt;CustomOutputCachePolicy&gt; logger)&#10;        {&#10;            _redisService = redisService;&#10;            _logger = logger;&#10;        }&#10;&#10;        public async ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation)&#10;        {&#10;            var request = context.HttpContext.Request;&#10;            &#10;            // Only cache POST requests to /api/math&#10;            if (request.Method == &quot;POST&quot; &amp;&amp; request.Path.StartsWithSegments(&quot;/api/math&quot;))&#10;            {&#10;                try&#10;                {&#10;                    // Read the request body to extract MathRequest&#10;                    request.EnableBuffering();&#10;                    request.Body.Position = 0;&#10;                    &#10;                    using var reader = new StreamReader(request.Body, leaveOpen: true);&#10;                    var body = await reader.ReadToEndAsync();&#10;                    request.Body.Position = 0;&#10;                    &#10;                    var mathRequest = JsonSerializer.Deserialize&lt;MathRequest&gt;(body, new JsonSerializerOptions&#10;                    {&#10;                        PropertyNameCaseInsensitive = true&#10;                    });&#10;                    &#10;                    if (mathRequest != null)&#10;                    {&#10;                        var cacheKey = $&quot;math:{mathRequest.Operation}:{mathRequest.X}:{mathRequest.Y}&quot;;&#10;                        &#10;                        // Check if we already have this calculation in Redis&#10;                        var cachedResult = await _redisService.GetMathDataAsync(cacheKey);&#10;                        if (cachedResult.HasValue)&#10;                        {&#10;                            _logger.LogInformation(&quot;Cache hit for key: {CacheKey}&quot;, cacheKey);&#10;                            &#10;                            // Create response from cached data&#10;                            var response = new MathResponse&#10;                            {&#10;                                Result = cachedResult.Value,&#10;                                Success = true&#10;                            };&#10;                            &#10;                            context.HttpContext.Response.StatusCode = 200;&#10;                            context.HttpContext.Response.ContentType = &quot;application/json&quot;;&#10;                            await context.HttpContext.Response.WriteAsync(&#10;                                JsonSerializer.Serialize(response, new JsonSerializerOptions &#10;                                { &#10;                                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase &#10;                                }));&#10;                            &#10;                            context.ResponseCached = true;&#10;                            return;&#10;                        }&#10;                        &#10;                        _logger.LogInformation(&quot;Cache miss for key: {CacheKey}&quot;, cacheKey);&#10;                        &#10;                        // Store the cache key for later use in response caching&#10;                        context.HttpContext.Items[&quot;CacheKey&quot;] = cacheKey;&#10;                        context.HttpContext.Items[&quot;MathRequest&quot;] = mathRequest;&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    _logger.LogWarning(ex, &quot;Failed to process cache request for math endpoint&quot;);&#10;                }&#10;            }&#10;            &#10;            // Allow request to proceed&#10;            context.AllowCacheLookup = true;&#10;            context.AllowCacheStorage = true;&#10;        }&#10;&#10;        public ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation)&#10;        {&#10;            // Custom cache serving is handled in CacheRequestAsync&#10;            return ValueTask.CompletedTask;&#10;        }&#10;&#10;        public async ValueTask ServeFromOriginAsync(OutputCacheContext context, CancellationToken cancellation)&#10;        {&#10;            // Store the response in Redis after it's generated&#10;            if (context.HttpContext.Items.TryGetValue(&quot;CacheKey&quot;, out var cacheKeyObj) &amp;&amp;&#10;                context.HttpContext.Items.TryGetValue(&quot;MathRequest&quot;, out var mathRequestObj) &amp;&amp;&#10;                cacheKeyObj is string cacheKey &amp;&amp;&#10;                mathRequestObj is MathRequest mathRequest)&#10;            {&#10;                try&#10;                {&#10;                    // Capture the response&#10;                    var originalBody = context.HttpContext.Response.Body;&#10;                    using var responseBody = new MemoryStream();&#10;                    context.HttpContext.Response.Body = responseBody;&#10;                    &#10;                    // Let the request complete&#10;                    await context.Next(context.HttpContext);&#10;                    &#10;                    // Read the response&#10;                    responseBody.Position = 0;&#10;                    var responseContent = await new StreamReader(responseBody).ReadToEndAsync();&#10;                    &#10;                    // Parse and cache the result&#10;                    if (!string.IsNullOrEmpty(responseContent))&#10;                    {&#10;                        var mathResponse = JsonSerializer.Deserialize&lt;MathResponse&gt;(responseContent, &#10;                            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });&#10;                        &#10;                        if (mathResponse?.Success == true)&#10;                        {&#10;                            await _redisService.SetMathDataAsync(mathRequest, mathResponse.Result, TimeSpan.FromSeconds(30));&#10;                            _logger.LogInformation(&quot;Cached result for key: {CacheKey}, Result: {Result}&quot;, cacheKey, mathResponse.Result);&#10;                        }&#10;                    }&#10;                    &#10;                    // Write response back to original stream&#10;                    responseBody.Position = 0;&#10;                    await responseBody.CopyToAsync(originalBody);&#10;                    context.HttpContext.Response.Body = originalBody;&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    _logger.LogWarning(ex, &quot;Failed to cache response for key: {CacheKey}&quot;, cacheKey);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Standard request processing&#10;                await context.Next(context.HttpContext);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Extensions/OutputCacheExtensions.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Extensions/OutputCacheExtensions.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using Microsoft.AspNetCore.OutputCaching;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using IO.Swagger.Services;&#10;using IO.Swagger.Models.Math;&#10;using System.Text.Json;&#10;using Microsoft.AspNetCore.Http;&#10;&#10;namespace IO.Swagger.Extensions&#10;{&#10;    public static class OutputCacheExtensions&#10;    {&#10;        public static IServiceCollection AddCustomOutputCache(this IServiceCollection services)&#10;        {&#10;            services.AddOutputCache(options =&gt;&#10;            {&#10;                // Math calculation cache policy with Redis integration&#10;                options.AddPolicy(&quot;CacheMathCalculation&quot;, policy =&gt;&#10;                {&#10;                    policy.Expire(TimeSpan.FromSeconds(30))&#10;                          .SetVaryByRouteValue(&quot;*&quot;)&#10;                          .VaryByValue(async (httpContext, cancellationToken) =&gt;&#10;                          {&#10;                              // Use RedisService for advanced caching logic&#10;                              var redisService = httpContext.RequestServices.GetRequiredService&lt;RadisService&gt;();&#10;                              &#10;                              // Extract math request from body for cache key generation&#10;                              if (httpContext.Request.ContentType?.Contains(&quot;application/json&quot;) == true)&#10;                              {&#10;                                  httpContext.Request.EnableBuffering();&#10;                                  httpContext.Request.Body.Position = 0;&#10;                                  &#10;                                  using var reader = new StreamReader(httpContext.Request.Body, leaveOpen: true);&#10;                                  var body = await reader.ReadToEndAsync();&#10;                                  httpContext.Request.Body.Position = 0;&#10;                                  &#10;                                  try&#10;                                  {&#10;                                      var mathRequest = JsonSerializer.Deserialize&lt;MathRequest&gt;(body, new JsonSerializerOptions&#10;                                      {&#10;                                          PropertyNameCaseInsensitive = true&#10;                                      });&#10;                                      &#10;                                      if (mathRequest != null)&#10;                                      {&#10;                                          var cacheKey = $&quot;{mathRequest.Operation}:{mathRequest.X}:{mathRequest.Y}&quot;;&#10;                                          return KeyValuePair.Create(&quot;mathKey&quot;, (object)cacheKey);&#10;                                      }&#10;                                  }&#10;                                  catch&#10;                                  {&#10;                                      // Fallback to route-based caching&#10;                                  }&#10;                              }&#10;                              &#10;                              // Fallback cache key&#10;                              return KeyValuePair.Create(&quot;route&quot;, (object)httpContext.Request.Path.ToString());&#10;                          });&#10;                });&#10;                &#10;                // Simple test endpoint cache policy&#10;                options.AddPolicy(&quot;CacheTestEndpoint&quot;, policy =&gt;&#10;                {&#10;                    policy.Expire(TimeSpan.FromSeconds(30))&#10;                          .SetVaryByRouteValue(&quot;*&quot;);&#10;                });&#10;            });&#10;            &#10;            return services;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using Microsoft.AspNetCore.OutputCaching;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using IO.Swagger.Services;&#10;using IO.Swagger.Models.Math;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Extensions&#10;{&#10;    public static class OutputCacheExtensions&#10;    {&#10;        public static IServiceCollection AddCustomOutputCache(this IServiceCollection services)&#10;        {&#10;            services.AddOutputCache(options =&gt;&#10;            {&#10;                // Math calculation cache policy with Redis integration&#10;                options.AddPolicy(&quot;CacheMathCalculation&quot;, policy =&gt;&#10;                {&#10;                    policy.Expire(TimeSpan.FromSeconds(30))&#10;                          .SetVaryByRouteValue(&quot;*&quot;)&#10;                          .VaryByValue(async (httpContext, cancellationToken) =&gt;&#10;                          {&#10;                              // Extract math request from body for cache key generation&#10;                              if (httpContext.Request.ContentType?.Contains(&quot;application/json&quot;) == true)&#10;                              {&#10;                                  httpContext.Request.EnableBuffering();&#10;                                  httpContext.Request.Body.Position = 0;&#10;                                  &#10;                                  using var reader = new StreamReader(httpContext.Request.Body, leaveOpen: true);&#10;                                  var body = await reader.ReadToEndAsync();&#10;                                  httpContext.Request.Body.Position = 0;&#10;                                  &#10;                                  try&#10;                                  {&#10;                                      var mathRequest = JsonSerializer.Deserialize&lt;MathRequest&gt;(body, new JsonSerializerOptions&#10;                                      {&#10;                                          PropertyNameCaseInsensitive = true&#10;                                      });&#10;                                      &#10;                                      if (mathRequest != null)&#10;                                      {&#10;                                          var cacheKey = $&quot;{mathRequest.Operation}:{mathRequest.X}:{mathRequest.Y}&quot;;&#10;                                          return KeyValuePair.Create(&quot;mathKey&quot;, (object)cacheKey);&#10;                                      }&#10;                                  }&#10;                                  catch&#10;                                  {&#10;                                      // Fallback to route-based caching&#10;                                  }&#10;                              }&#10;                              &#10;                              // Fallback cache key&#10;                              return KeyValuePair.Create(&quot;route&quot;, (object)httpContext.Request.Path.ToString());&#10;                          });&#10;                });&#10;                &#10;                // Simple test endpoint cache policy&#10;                options.AddPolicy(&quot;CacheTestEndpoint&quot;, policy =&gt;&#10;                {&#10;                    policy.Expire(TimeSpan.FromSeconds(30))&#10;                          .SetVaryByRouteValue(&quot;*&quot;);&#10;                });&#10;            });&#10;            &#10;            return services;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/IO.Swagger.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/IO.Swagger.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;Description&gt;IO.Swagger&lt;/Description&gt;&#10;    &lt;Copyright&gt;IO.Swagger&lt;/Copyright&gt;&#10;    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;&#10;    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&#10;    &lt;PreserveCompilationContext&gt;true&lt;/PreserveCompilationContext&gt;&#10;    &lt;AssemblyName&gt;IO.Swagger&lt;/AssemblyName&gt;&#10;    &lt;PackageId&gt;IO.Swagger&lt;/PackageId&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Aspire.Confluent.Kafka&quot; Version=&quot;9.4.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Aspire.StackExchange.Redis&quot; Version=&quot;9.4.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Aspire.StackExchange.Redis.OutputCaching&quot; Version=&quot;9.4.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.JwtBearer&quot; Version=&quot;9.0.8&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.IdentityModel.Tokens&quot; Version=&quot;8.13.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;System.IdentityModel.Tokens.Jwt&quot; Version=&quot;8.13.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;9.0.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore.SwaggerGen&quot; Version=&quot;9.0.3&quot;/&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore.SwaggerUI&quot; Version=&quot;9.0.3&quot;/&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore.Annotations&quot; Version=&quot;9.0.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.AspNetCore&quot; Version=&quot;9.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.Formatting.Json&quot; Version=&quot;1.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.Sinks.Console&quot; Version=&quot;6.0.0&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;DotNetCliToolReference Include=&quot;Microsoft.VisualStudio.Web.CodeGeneration.Tools&quot; Version=&quot;2.0.4&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\IO.Swagger.Services\IO.Swagger.Services.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;Folder Include=&quot;Extensions\&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;Description&gt;IO.Swagger&lt;/Description&gt;&#10;    &lt;Copyright&gt;IO.Swagger&lt;/Copyright&gt;&#10;    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;&#10;    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&#10;    &lt;PreserveCompilationContext&gt;true&lt;/PreserveCompilationContext&gt;&#10;    &lt;AssemblyName&gt;IO.Swagger&lt;/AssemblyName&gt;&#10;    &lt;PackageId&gt;IO.Swagger&lt;/PackageId&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Aspire.Confluent.Kafka&quot; Version=&quot;9.4.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Aspire.StackExchange.Redis&quot; Version=&quot;9.4.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Aspire.StackExchange.Redis.OutputCaching&quot; Version=&quot;9.4.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.JwtBearer&quot; Version=&quot;9.0.8&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.IdentityModel.Tokens&quot; Version=&quot;8.13.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;System.IdentityModel.Tokens.Jwt&quot; Version=&quot;8.13.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;9.0.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore.SwaggerGen&quot; Version=&quot;9.0.3&quot;/&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore.SwaggerUI&quot; Version=&quot;9.0.3&quot;/&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore.Annotations&quot; Version=&quot;9.0.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.AspNetCore&quot; Version=&quot;9.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.Extensions.Logging&quot; Version=&quot;8.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.Formatting.Compact&quot; Version=&quot;3.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.Sinks.Console&quot; Version=&quot;6.0.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Serilog.Sinks.File&quot; Version=&quot;6.0.0&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;DotNetCliToolReference Include=&quot;Microsoft.VisualStudio.Web.CodeGeneration.Tools&quot; Version=&quot;2.0.4&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\IO.Swagger.Services\IO.Swagger.Services.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;Folder Include=&quot;Extensions\&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Middleware/GlobalExceptionHandlingMiddleware.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Middleware/GlobalExceptionHandlingMiddleware.cs" />
              <option name="updatedContent" value="using Microsoft.AspNetCore.Mvc;&#10;using Serilog.Context;&#10;using System.Net;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Middleware;&#10;&#10;/// &lt;summary&gt;&#10;/// Global exception handling middleware with comprehensive error logging&#10;/// &lt;/summary&gt;&#10;public class GlobalExceptionHandlingMiddleware&#10;{&#10;    private readonly RequestDelegate _next;&#10;    private readonly ILogger&lt;GlobalExceptionHandlingMiddleware&gt; _logger;&#10;    private readonly IHostEnvironment _environment;&#10;&#10;    public GlobalExceptionHandlingMiddleware(&#10;        RequestDelegate next,&#10;        ILogger&lt;GlobalExceptionHandlingMiddleware&gt; logger,&#10;        IHostEnvironment environment)&#10;    {&#10;        _next = next;&#10;        _logger = logger;&#10;        _environment = environment;&#10;    }&#10;&#10;    public async Task InvokeAsync(HttpContext context)&#10;    {&#10;        try&#10;        {&#10;            await _next(context);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            await HandleExceptionAsync(context, ex);&#10;        }&#10;    }&#10;&#10;    private async Task HandleExceptionAsync(HttpContext context, Exception exception)&#10;    {&#10;        var correlationId = context.Response.Headers[&quot;X-Correlation-ID&quot;].FirstOrDefault();&#10;        &#10;        using (LogContext.PushProperty(&quot;CorrelationId&quot;, correlationId))&#10;        using (LogContext.PushProperty(&quot;ExceptionType&quot;, exception.GetType().Name))&#10;        using (LogContext.PushProperty(&quot;RequestPath&quot;, context.Request.Path))&#10;        using (LogContext.PushProperty(&quot;RequestMethod&quot;, context.Request.Method))&#10;        {&#10;            // Log the exception with full context&#10;            _logger.LogError(exception,&#10;                &quot;Unhandled exception occurred for {RequestMethod} {RequestPath} with correlation ID {CorrelationId}. &quot; +&#10;                &quot;Exception: {ExceptionMessage}, StackTrace: {StackTrace}&quot;,&#10;                context.Request.Method,&#10;                context.Request.Path,&#10;                correlationId,&#10;                exception.Message,&#10;                exception.StackTrace);&#10;&#10;            // Determine response based on exception type&#10;            var response = exception switch&#10;            {&#10;                ArgumentException =&gt; CreateErrorResponse(HttpStatusCode.BadRequest, &quot;Invalid request parameters&quot;, correlationId),&#10;                UnauthorizedAccessException =&gt; CreateErrorResponse(HttpStatusCode.Unauthorized, &quot;Access denied&quot;, correlationId),&#10;                KeyNotFoundException =&gt; CreateErrorResponse(HttpStatusCode.NotFound, &quot;Resource not found&quot;, correlationId),&#10;                TimeoutException =&gt; CreateErrorResponse(HttpStatusCode.RequestTimeout, &quot;Request timed out&quot;, correlationId),&#10;                InvalidOperationException =&gt; CreateErrorResponse(HttpStatusCode.BadRequest, &quot;Invalid operation&quot;, correlationId),&#10;                _ =&gt; CreateErrorResponse(HttpStatusCode.InternalServerError, &quot;An error occurred while processing your request&quot;, correlationId)&#10;            };&#10;&#10;            // In development, include more detailed error information&#10;            if (_environment.IsDevelopment())&#10;            {&#10;                response.Detail = exception.Message;&#10;                response.Extensions.Add(&quot;stackTrace&quot;, exception.StackTrace);&#10;                response.Extensions.Add(&quot;innerException&quot;, exception.InnerException?.Message);&#10;            }&#10;&#10;            context.Response.StatusCode = (int)response.Status!;&#10;            context.Response.ContentType = &quot;application/json&quot;;&#10;&#10;            var json = JsonSerializer.Serialize(response, new JsonSerializerOptions&#10;            {&#10;                PropertyNamingPolicy = JsonNamingPolicy.CamelCase&#10;            });&#10;&#10;            await context.Response.WriteAsync(json);&#10;        }&#10;    }&#10;&#10;    private static ProblemDetails CreateErrorResponse(HttpStatusCode statusCode, string title, string? correlationId)&#10;    {&#10;        return new ProblemDetails&#10;        {&#10;            Status = (int)statusCode,&#10;            Title = title,&#10;            Type = $&quot;https://httpstatuses.com/{(int)statusCode}&quot;,&#10;            Extensions =&#10;            {&#10;                { &quot;correlationId&quot;, correlationId },&#10;                { &quot;timestamp&quot;, DateTimeOffset.UtcNow.ToString(&quot;O&quot;) }&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Middleware/PerformanceMonitoringMiddleware.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Middleware/PerformanceMonitoringMiddleware.cs" />
              <option name="updatedContent" value="using System.Diagnostics;&#10;using Serilog.Context;&#10;&#10;namespace IO.Swagger.Middleware;&#10;&#10;/// &lt;summary&gt;&#10;/// Middleware for monitoring API performance and resource usage&#10;/// &lt;/summary&gt;&#10;public class PerformanceMonitoringMiddleware&#10;{&#10;    private readonly RequestDelegate _next;&#10;    private readonly ILogger&lt;PerformanceMonitoringMiddleware&gt; _logger;&#10;    private const int SlowRequestThresholdMs = 1000; // 1 second&#10;&#10;    public PerformanceMonitoringMiddleware(RequestDelegate next, ILogger&lt;PerformanceMonitoringMiddleware&gt; logger)&#10;    {&#10;        _next = next;&#10;        _logger = logger;&#10;    }&#10;&#10;    public async Task InvokeAsync(HttpContext context)&#10;    {&#10;        var stopwatch = Stopwatch.StartNew();&#10;        var correlationId = context.Response.Headers[&quot;X-Correlation-ID&quot;].FirstOrDefault();&#10;        &#10;        // Monitor memory before request&#10;        var memoryBefore = GC.GetTotalMemory(false);&#10;        &#10;        using (LogContext.PushProperty(&quot;CorrelationId&quot;, correlationId))&#10;        {&#10;            try&#10;            {&#10;                await _next(context);&#10;            }&#10;            finally&#10;            {&#10;                stopwatch.Stop();&#10;                var memoryAfter = GC.GetTotalMemory(false);&#10;                var memoryUsed = memoryAfter - memoryBefore;&#10;                &#10;                var performanceData = new&#10;                {&#10;                    RequestPath = context.Request.Path.Value,&#10;                    Method = context.Request.Method,&#10;                    StatusCode = context.Response.StatusCode,&#10;                    DurationMs = stopwatch.ElapsedMilliseconds,&#10;                    MemoryUsedBytes = memoryUsed,&#10;                    MemoryUsedKB = Math.Round(memoryUsed / 1024.0, 2),&#10;                    CorrelationId = correlationId&#10;                };&#10;&#10;                // Log performance metrics&#10;                if (stopwatch.ElapsedMilliseconds &gt; SlowRequestThresholdMs)&#10;                {&#10;                    _logger.LogWarning(&#10;                        &quot;SLOW REQUEST detected: {Method} {RequestPath} took {DurationMs}ms &quot; +&#10;                        &quot;(threshold: {ThresholdMs}ms). Memory used: {MemoryUsedKB}KB. &quot; +&#10;                        &quot;Status: {StatusCode}, CorrelationId: {CorrelationId}&quot;,&#10;                        performanceData.Method,&#10;                        performanceData.RequestPath,&#10;                        performanceData.DurationMs,&#10;                        SlowRequestThresholdMs,&#10;                        performanceData.MemoryUsedKB,&#10;                        performanceData.StatusCode,&#10;                        performanceData.CorrelationId);&#10;                }&#10;                else&#10;                {&#10;                    _logger.LogDebug(&#10;                        &quot;Performance metrics: {Method} {RequestPath} completed in {DurationMs}ms. &quot; +&#10;                        &quot;Memory used: {MemoryUsedKB}KB, Status: {StatusCode}, CorrelationId: {CorrelationId}&quot;,&#10;                        performanceData.Method,&#10;                        performanceData.RequestPath,&#10;                        performanceData.DurationMs,&#10;                        performanceData.MemoryUsedKB,&#10;                        performanceData.StatusCode,&#10;                        performanceData.CorrelationId);&#10;                }&#10;&#10;                // Add performance headers to response&#10;                context.Response.Headers.Add(&quot;X-Response-Time&quot;, $&quot;{stopwatch.ElapsedMilliseconds}ms&quot;);&#10;                context.Response.Headers.Add(&quot;X-Memory-Used&quot;, $&quot;{performanceData.MemoryUsedKB}KB&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Middleware/RequestResponseLoggingMiddleware.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Middleware/RequestResponseLoggingMiddleware.cs" />
              <option name="updatedContent" value="using Microsoft.Extensions.Logging;&#10;using Serilog.Context;&#10;using System.Diagnostics;&#10;using System.Text;&#10;&#10;namespace IO.Swagger.Middleware;&#10;&#10;/// &lt;summary&gt;&#10;/// Middleware for comprehensive request/response logging with correlation tracking&#10;/// &lt;/summary&gt;&#10;public class RequestResponseLoggingMiddleware&#10;{&#10;    private readonly RequestDelegate _next;&#10;    private readonly ILogger&lt;RequestResponseLoggingMiddleware&gt; _logger;&#10;&#10;    public RequestResponseLoggingMiddleware(RequestDelegate next, ILogger&lt;RequestResponseLoggingMiddleware&gt; logger)&#10;    {&#10;        _next = next;&#10;        _logger = logger;&#10;    }&#10;&#10;    public async Task InvokeAsync(HttpContext context)&#10;    {&#10;        var stopwatch = Stopwatch.StartNew();&#10;        var correlationId = context.Request.Headers[&quot;X-Correlation-ID&quot;].FirstOrDefault() &#10;                           ?? Guid.NewGuid().ToString();&#10;        &#10;        // Add correlation ID to response headers&#10;        context.Response.Headers.Add(&quot;X-Correlation-ID&quot;, correlationId);&#10;        &#10;        // Enrich logs with correlation ID and request context&#10;        using (LogContext.PushProperty(&quot;CorrelationId&quot;, correlationId))&#10;        using (LogContext.PushProperty(&quot;RequestPath&quot;, context.Request.Path))&#10;        using (LogContext.PushProperty(&quot;RequestMethod&quot;, context.Request.Method))&#10;        using (LogContext.PushProperty(&quot;UserAgent&quot;, context.Request.Headers[&quot;User-Agent&quot;].ToString()))&#10;        using (LogContext.PushProperty(&quot;RemoteIpAddress&quot;, context.Connection.RemoteIpAddress?.ToString()))&#10;        {&#10;            await LogRequestAsync(context, correlationId);&#10;            &#10;            // Capture original response body stream&#10;            var originalBodyStream = context.Response.Body;&#10;            &#10;            using var responseBody = new MemoryStream();&#10;            context.Response.Body = responseBody;&#10;            &#10;            try&#10;            {&#10;                await _next(context);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                stopwatch.Stop();&#10;                _logger.LogError(ex, &#10;                    &quot;Request failed for {RequestMethod} {RequestPath} with correlation ID {CorrelationId}. Duration: {Duration}ms&quot;,&#10;                    context.Request.Method, &#10;                    context.Request.Path, &#10;                    correlationId, &#10;                    stopwatch.ElapsedMilliseconds);&#10;                throw;&#10;            }&#10;            &#10;            stopwatch.Stop();&#10;            await LogResponseAsync(context, correlationId, stopwatch.ElapsedMilliseconds);&#10;            &#10;            // Copy response body back to original stream&#10;            await responseBody.CopyToAsync(originalBodyStream);&#10;        }&#10;    }&#10;&#10;    private async Task LogRequestAsync(HttpContext context, string correlationId)&#10;    {&#10;        var request = context.Request;&#10;        var requestBody = string.Empty;&#10;&#10;        if (request.ContentLength &gt; 0 &amp;&amp; &#10;            request.ContentType?.Contains(&quot;application/json&quot;) == true)&#10;        {&#10;            request.EnableBuffering();&#10;            &#10;            using var reader = new StreamReader(request.Body, Encoding.UTF8, leaveOpen: true);&#10;            requestBody = await reader.ReadToEndAsync();&#10;            request.Body.Position = 0;&#10;        }&#10;&#10;        _logger.LogInformation(&#10;            &quot;Incoming request: {RequestMethod} {RequestPath} with correlation ID {CorrelationId}. &quot; +&#10;            &quot;Content-Type: {ContentType}, Content-Length: {ContentLength}, Body: {RequestBody}&quot;,&#10;            request.Method,&#10;            request.Path + request.QueryString,&#10;            correlationId,&#10;            request.ContentType ?? &quot;N/A&quot;,&#10;            request.ContentLength ?? 0,&#10;            !string.IsNullOrEmpty(requestBody) ? requestBody : &quot;N/A&quot;);&#10;    }&#10;&#10;    private async Task LogResponseAsync(HttpContext context, string correlationId, long durationMs)&#10;    {&#10;        var response = context.Response;&#10;        var responseBody = string.Empty;&#10;&#10;        if (response.Body.CanSeek &amp;&amp; response.Body.Length &gt; 0)&#10;        {&#10;            response.Body.Seek(0, SeekOrigin.Begin);&#10;            using var reader = new StreamReader(response.Body, Encoding.UTF8, leaveOpen: true);&#10;            responseBody = await reader.ReadToEndAsync();&#10;            response.Body.Seek(0, SeekOrigin.Begin);&#10;        }&#10;&#10;        var logLevel = response.StatusCode &gt;= 400 ? LogLevel.Warning : LogLevel.Information;&#10;        &#10;        _logger.Log(logLevel,&#10;            &quot;Outgoing response: {RequestMethod} {RequestPath} returned {StatusCode} with correlation ID {CorrelationId}. &quot; +&#10;            &quot;Duration: {Duration}ms, Content-Type: {ContentType}, Body: {ResponseBody}&quot;,&#10;            context.Request.Method,&#10;            context.Request.Path,&#10;            response.StatusCode,&#10;            correlationId,&#10;            durationMs,&#10;            response.ContentType ?? &quot;N/A&quot;,&#10;            !string.IsNullOrEmpty(responseBody) ? responseBody : &quot;N/A&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Models/Kafka/CalculationEvents.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Models/Kafka/CalculationEvents.cs" />
              <option name="updatedContent" value="using System.Text.Json.Serialization;&#10;&#10;namespace IO.Swagger.Models.Kafka;&#10;&#10;public class CalculationStartedEvent&#10;{&#10;    [JsonPropertyName(&quot;operationId&quot;)]&#10;    public string OperationId { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;operation&quot;)]&#10;    public string Operation { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;x&quot;)]&#10;    public double X { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;y&quot;)]&#10;    public double Y { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;timestamp&quot;)]&#10;    public DateTime Timestamp { get; set; } = DateTime.UtcNow;&#10;    &#10;    [JsonPropertyName(&quot;userId&quot;)]&#10;    public string? UserId { get; set; }&#10;}&#10;&#10;public class CalculationCompletedEvent&#10;{&#10;    [JsonPropertyName(&quot;operationId&quot;)]&#10;    public string OperationId { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;operation&quot;)]&#10;    public string Operation { get; set; } = string.Empty;&#10;    &#10;    [JsonPropertyName(&quot;x&quot;)]&#10;    public double X { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;y&quot;)]&#10;    public double Y { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;result&quot;)]&#10;    public double? Result { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;success&quot;)]&#10;    public bool Success { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;error&quot;)]&#10;    public string? Error { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;timestamp&quot;)]&#10;    public DateTime Timestamp { get; set; } = DateTime.UtcNow;&#10;    &#10;    [JsonPropertyName(&quot;executionTimeMs&quot;)]&#10;    public long ExecutionTimeMs { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;cacheHit&quot;)]&#10;    public bool CacheHit { get; set; }&#10;    &#10;    [JsonPropertyName(&quot;userId&quot;)]&#10;    public string? UserId { get; set; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Models/MathBody.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Models/MathBody.cs" />
              <option name="originalContent" value="/*&#10; * Sample Access Code Flow OAuth2 Project&#10; *&#10; * This is an example of using OAuth2 Access Code Flow in a specification to describe security to your API.&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; * &#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System;&#10;using System.Text;&#10;using System.Runtime.Serialization;&#10;using Newtonsoft.Json;&#10;&#10;namespace IO.Swagger.Models&#10;{&#10;    /// &lt;summary&gt;&#10;    ///&#10;    /// &lt;/summary&gt;&#10;    [DataContract]&#10;    public partial class MathBody : IEquatable&lt;MathBody&gt;&#10;    { &#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets X&#10;        /// &lt;/summary&gt;&#10;        [DataMember(Name=&quot;x&quot;)]&#10;        public decimal? X { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets Y&#10;        /// &lt;/summary&gt;&#10;        [DataMember(Name=&quot;y&quot;)]&#10;        public decimal? Y { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets or Sets Operation&#10;        /// &lt;/summary&gt;&#10;        [DataMember(Name=&quot;operation&quot;)]&#10;        public OperationEnum? Operation { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;String presentation of the object&lt;/returns&gt;&#10;        public override string ToString()&#10;        {&#10;            var sb = new StringBuilder();&#10;            sb.Append(&quot;class MathBody {\n&quot;);&#10;            sb.Append(&quot;  X: &quot;).Append(X).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;  Y: &quot;).Append(Y).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;  Operation: &quot;).Append(Operation).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;}\n&quot;);&#10;            return sb.ToString();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the JSON string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;        public string ToJson()&#10;        {&#10;            return JsonConvert.SerializeObject(this, Formatting.Indented);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if objects are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public override bool Equals(object obj)&#10;        {&#10;            if (ReferenceEquals(null, obj)) return false;&#10;            if (ReferenceEquals(this, obj)) return true;&#10;            return obj.GetType() == GetType() &amp;&amp; Equals((MathBody)obj);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if MathBody instances are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;other&quot;&gt;Instance of MathBody to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public bool Equals(MathBody other)&#10;        {&#10;            if (ReferenceEquals(null, other)) return false;&#10;            if (ReferenceEquals(this, other)) return true;&#10;&#10;            return &#10;                (&#10;                    X == other.X ||&#10;                    X != null &amp;&amp;&#10;                    X.Equals(other.X)&#10;                ) &amp;&amp; &#10;                (&#10;                    Y == other.Y ||&#10;                    Y != null &amp;&amp;&#10;                    Y.Equals(other.Y)&#10;                ) &amp;&amp; &#10;                (&#10;                    Operation == other.Operation ||&#10;                    Operation != null &amp;&amp;&#10;                    Operation.Equals(other.Operation)&#10;                );&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets the hash code&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;Hash code&lt;/returns&gt;&#10;        public override int GetHashCode()&#10;        {&#10;            unchecked // Overflow is fine, just wrap&#10;            {&#10;                var hashCode = 41;&#10;                // Suitable nullity checks etc, of course :)&#10;                if (X != null)&#10;                    hashCode = hashCode * 59 + X.GetHashCode();&#10;                if (Y != null)&#10;                    hashCode = hashCode * 59 + Y.GetHashCode();&#10;                if (Operation != null)&#10;                    hashCode = hashCode * 59 + Operation.GetHashCode();&#10;                return hashCode;&#10;            }&#10;        }&#10;&#10;        #region Operators&#10;        #pragma warning disable 1591&#10;&#10;        public static bool operator ==(MathBody left, MathBody right)&#10;        {&#10;            return Equals(left, right);&#10;        }&#10;&#10;        public static bool operator !=(MathBody left, MathBody right)&#10;        {&#10;            return !Equals(left, right);&#10;        }&#10;&#10;        #pragma warning restore 1591&#10;        #endregion Operators&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Sample Access Code Flow OAuth2 Project&#10; *&#10; * This is an example of using OAuth2 Access Code Flow in a specification to describe security to your API.&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; * &#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;using System;&#10;using System.Text;&#10;using System.ComponentModel.DataAnnotations;&#10;using System.Runtime.Serialization;&#10;using Newtonsoft.Json;&#10;using Newtonsoft.Json.Converters;&#10;&#10;namespace IO.Swagger.Models&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Mathematical operation request body&#10;    /// &lt;/summary&gt;&#10;    [DataContract]&#10;    public partial class MathBody : IEquatable&lt;MathBody&gt;&#10;    { &#10;        /// &lt;summary&gt;&#10;        /// Mathematical operation to perform&#10;        /// &lt;/summary&gt;&#10;        [JsonConverter(typeof(StringEnumConverter))]&#10;        public enum OperationEnum&#10;        {&#10;            /// &lt;summary&gt;&#10;            /// Addition operation&#10;            /// &lt;/summary&gt;&#10;            [EnumMember(Value = &quot;add&quot;)]&#10;            Add = 1,&#10;&#10;            /// &lt;summary&gt;&#10;            /// Subtraction operation&#10;            /// &lt;/summary&gt;&#10;            [EnumMember(Value = &quot;subtract&quot;)]&#10;            Subtract = 2,&#10;&#10;            /// &lt;summary&gt;&#10;            /// Multiplication operation&#10;            /// &lt;/summary&gt;&#10;            [EnumMember(Value = &quot;multiply&quot;)]&#10;            Multiply = 3,&#10;&#10;            /// &lt;summary&gt;&#10;            /// Division operation&#10;            /// &lt;/summary&gt;&#10;            [EnumMember(Value = &quot;divide&quot;)]&#10;            Divide = 4&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// First operand&#10;        /// &lt;/summary&gt;&#10;        /// &lt;value&gt;First operand&lt;/value&gt;&#10;        [DataMember(Name=&quot;operand1&quot;)]&#10;        [JsonProperty(&quot;operand1&quot;)]&#10;        [Required]&#10;        public double Operand1 { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Second operand&#10;        /// &lt;/summary&gt;&#10;        /// &lt;value&gt;Second operand&lt;/value&gt;&#10;        [DataMember(Name=&quot;operand2&quot;)]&#10;        [JsonProperty(&quot;operand2&quot;)]&#10;        [Required]&#10;        public double Operand2 { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Mathematical operation to perform&#10;        /// &lt;/summary&gt;&#10;        /// &lt;value&gt;Mathematical operation to perform&lt;/value&gt;&#10;        [DataMember(Name=&quot;operation&quot;)]&#10;        [JsonProperty(&quot;operation&quot;)]&#10;        [Required]&#10;        public OperationEnum Operation { get; set; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;String presentation of the object&lt;/returns&gt;&#10;        public override string ToString()&#10;        {&#10;            var sb = new StringBuilder();&#10;            sb.Append(&quot;class MathBody {\n&quot;);&#10;            sb.Append(&quot;  Operand1: &quot;).Append(Operand1).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;  Operand2: &quot;).Append(Operand2).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;  Operation: &quot;).Append(Operation).Append(&quot;\n&quot;);&#10;            sb.Append(&quot;}\n&quot;);&#10;            return sb.ToString();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the JSON string presentation of the object&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;JSON string presentation of the object&lt;/returns&gt;&#10;        public string ToJson()&#10;        {&#10;            return JsonConvert.SerializeObject(this, Formatting.Indented);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if objects are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;obj&quot;&gt;Object to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public override bool Equals(object obj)&#10;        {&#10;            if (ReferenceEquals(null, obj)) return false;&#10;            if (ReferenceEquals(this, obj)) return true;&#10;            return obj.GetType() == GetType() &amp;&amp; Equals((MathBody)obj);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns true if MathBody instances are equal&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;other&quot;&gt;Instance of MathBody to be compared&lt;/param&gt;&#10;        /// &lt;returns&gt;Boolean&lt;/returns&gt;&#10;        public bool Equals(MathBody other)&#10;        {&#10;            if (ReferenceEquals(null, other)) return false;&#10;            if (ReferenceEquals(this, other)) return true;&#10;&#10;            return &#10;                (&#10;                    Operand1 == other.Operand1 ||&#10;                    Operand1 != null &amp;&amp;&#10;                    Operand1.Equals(other.Operand1)&#10;                ) &amp;&amp; &#10;                (&#10;                    Operand2 == other.Operand2 ||&#10;                    Operand2 != null &amp;&amp;&#10;                    Operand2.Equals(other.Operand2)&#10;                ) &amp;&amp; &#10;                (&#10;                    Operation == other.Operation ||&#10;                    Operation != null &amp;&amp;&#10;                    Operation.Equals(other.Operation)&#10;                );&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets the hash code&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;Hash code&lt;/returns&gt;&#10;        public override int GetHashCode()&#10;        {&#10;            unchecked // Overflow is fine, just wrap&#10;            {&#10;                var hashCode = 41;&#10;                // Suitable nullity checks etc, of course :)&#10;                if (Operand1 != null)&#10;                    hashCode = hashCode * 59 + Operand1.GetHashCode();&#10;                if (Operand2 != null)&#10;                    hashCode = hashCode * 59 + Operand2.GetHashCode();&#10;                if (Operation != null)&#10;                    hashCode = hashCode * 59 + Operation.GetHashCode();&#10;                return hashCode;&#10;            }&#10;        }&#10;&#10;        #region Operators&#10;        #pragma warning disable 1591&#10;&#10;        public static bool operator ==(MathBody left, MathBody right)&#10;        {&#10;            return Equals(left, right);&#10;        }&#10;&#10;        public static bool operator !=(MathBody left, MathBody right)&#10;        {&#10;            return !Equals(left, right);&#10;        }&#10;&#10;        #pragma warning restore 1591&#10;        #endregion Operators&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Program.cs" />
              <option name="originalContent" value="using System;&#10;using System.IO;&#10;using System.Text;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.OpenApi.Models;&#10;using Microsoft.IdentityModel.Tokens;&#10;using IO.Swagger.Filters;&#10;using IO.Swagger.Middleware;&#10;using IO.Swagger.Services;&#10;using IO.Swagger.Services.Math;&#10;using Microsoft.AspNetCore.Builder;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Serilog;&#10;using Serilog.Events;&#10;using Serilog.Formatting.Json;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Configure Serilog for robust logging&#10;Log.Logger = new LoggerConfiguration()&#10;    .MinimumLevel.Information()&#10;    .MinimumLevel.Override(&quot;Microsoft&quot;, LogEventLevel.Warning)&#10;    .MinimumLevel.Override(&quot;Microsoft.Hosting.Lifetime&quot;, LogEventLevel.Information)&#10;    .MinimumLevel.Override(&quot;System&quot;, LogEventLevel.Warning)&#10;    .MinimumLevel.Override(&quot;Microsoft.AspNetCore.Authentication&quot;, LogEventLevel.Information)&#10;    .Enrich.FromLogContext()&#10;    .Enrich.WithProperty(&quot;ApplicationName&quot;, &quot;IO.Swagger.API&quot;)&#10;    .Enrich.WithProperty(&quot;Environment&quot;, builder.Environment.EnvironmentName)&#10;    .WriteTo.Console(new JsonFormatter())&#10;    .WriteTo.File(&#10;        new JsonFormatter(),&#10;        &quot;logs/io-swagger-.log&quot;,&#10;        rollingInterval: RollingInterval.Day,&#10;        retainedFileCountLimit: 30,&#10;        fileSizeLimitBytes: 100 * 1024 * 1024, // 100MB&#10;        rollOnFileSizeLimit: true)&#10;    .CreateLogger();&#10;&#10;// Use Serilog as the logging provider&#10;builder.Host.UseSerilog();&#10;&#10;// Register Aspire ServiceDefaults &amp; other services&#10;builder.AddServiceDefaults();&#10;builder.AddRedisClient(connectionName:&quot;redis&quot;);&#10;builder.Services.AddStackExchangeRedisOutputCache(options =&gt; {&#10;&#9;options.Configuration = builder.Configuration[&quot;Connection-Strings:redis&quot;];&#10;});&#10;builder.Services.AddOutputCache();&#10;builder.Services.AddSingleton&lt;IMathService,MathService&gt;();&#10;builder.Services.AddSingleton&lt;ICalculatorBusinessLogicService,CalculatorBusinessLogicService&gt;();&#10;builder.Services.AddSingleton&lt;RedisService&gt;();&#10;builder.Services.AddScoped&lt;IAuthenticationService,AuthenticationService&gt;();&#10;// Add Kafka services&#10;builder.AddKafkaProducer&lt;string,string&gt;(&quot;kafka&quot;);&#10;builder.Services.AddSingleton&lt;IO.Swagger.Services.Kafka.IKafkaProducerService,IO.Swagger.Services.Kafka.KafkaProducerService&gt;();&#10;builder.Services.AddHostedService&lt;IO.Swagger.Services.Kafka.KafkaConsumerService&gt;();&#10;// Add HttpContextAccessor for user context in services&#10;builder.Services.AddHttpContextAccessor();&#10;// Add framework services with System.Text.Json (replace Newtonsoft.Json)&#10;builder.Services.AddControllers()&#10;&#9;   .AddJsonOptions(options =&gt; {&#10;&#9;&#9;   options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;&#9;&#9;   options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));&#10;&#9;&#9;   options.JsonSerializerOptions.WriteIndented = true;&#10;&#9;   })&#10;&#9;   .AddXmlSerializerFormatters();&#10;// Configure JWT Authentication&#10;var jwtSettings = builder.Configuration.GetSection(&quot;Jwt&quot;);&#10;var key = Encoding.UTF8.GetBytes(jwtSettings[&quot;Key&quot;]);&#10;builder.Services.AddAuthentication(options =&gt; {&#10;&#9;&#9;   options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;&#10;&#9;&#9;   options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;&#10;&#9;   })&#10;&#9;   .AddJwtBearer(options =&gt; {&#10;&#9;&#9;   options.RequireHttpsMetadata = false; // Set to true in production&#10;&#9;&#9;   options.SaveToken = true;&#10;&#9;&#9;   options.TokenValidationParameters = new TokenValidationParameters {&#10;&#9;&#9;&#9;   ValidateIssuerSigningKey = true,&#10;&#9;&#9;&#9;   IssuerSigningKey = new SymmetricSecurityKey(key),&#10;&#9;&#9;&#9;   ValidateIssuer = true,&#10;&#9;&#9;&#9;   ValidIssuer = jwtSettings[&quot;Issuer&quot;],&#10;&#9;&#9;&#9;   ValidateAudience = true,&#10;&#9;&#9;&#9;   ValidAudience = jwtSettings[&quot;Audience&quot;],&#10;&#9;&#9;&#9;   ValidateLifetime = true,&#10;&#9;&#9;&#9;   ClockSkew = TimeSpan.Zero&#10;&#9;&#9;   };&#10;&#9;   });&#10;builder.Services.AddAuthorization();&#10;builder.Services.AddSwaggerGen(c =&gt; {&#10;&#9;c.SwaggerDoc(&quot;1.0.0&quot;,&#10;&#9;&#9;&#9;&#9; new OpenApiInfo {&#10;&#9;&#9;&#9;&#9;&#9; Version = &quot;1.0.0&quot;,&#10;&#9;&#9;&#9;&#9;&#9; Title = &quot;Sample JWT Bearer Authentication Project&quot;,&#10;&#9;&#9;&#9;&#9;&#9; Description = &quot;Sample JWT Bearer Authentication Project .NET 9 Web API&quot;,&#10;&#9;&#9;&#9;&#9;&#9; Contact = new OpenApiContact {&#10;&#9;&#9;&#9;&#9;&#9;&#9; Name = &quot;Swagger Codegen Contributors&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9; Url = new Uri(&quot;https://github.com/swagger-api/swagger-codegen&quot;),&#10;&#9;&#9;&#9;&#9;&#9;&#9; Email = &quot;admin@admin.com&quot;&#10;&#9;&#9;&#9;&#9;&#9; },&#10;&#9;&#9;&#9;&#9;&#9; TermsOfService = new Uri(&quot;https://www.example.com/policy&quot;)&#10;&#9;&#9;&#9;&#9; });&#10;&#10;&#9;// Add JWT Authentication to Swagger&#10;&#9;c.AddSecurityDefinition(&quot;Bearer&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;new OpenApiSecurityScheme {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Description = &quot;JWT Authorization header using the Bearer scheme. Example: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &quot;Authorization&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;In = ParameterLocation.Header,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Type = SecuritySchemeType.ApiKey,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Scheme = &quot;Bearer&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;});&#10;&#9;c.AddSecurityRequirement(new OpenApiSecurityRequirement {&#10;&#9;&#9;{&#10;&#9;&#9;&#9;new OpenApiSecurityScheme {&#10;&#9;&#9;&#9;&#9;Reference = new OpenApiReference {&#10;&#9;&#9;&#9;&#9;&#9;Type = ReferenceType.SecurityScheme,&#10;&#9;&#9;&#9;&#9;&#9;Id = &quot;Bearer&quot;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;[]&#10;&#9;&#9;}&#10;&#9;});&#10;&#9;c.CustomSchemaIds(type =&gt; type.FullName);&#10;&#9;c.IncludeXmlComments($&quot;{AppContext.BaseDirectory}{Path.DirectorySeparatorChar}{builder.Environment.ApplicationName}.xml&quot;);&#10;&#9;c.OperationFilter&lt;GeneratePathParamsValidationFilter&gt;();&#10;});&#10;var app = builder.Build();&#10;&#10;// Add comprehensive logging middleware pipeline&#10;app.UseMiddleware&lt;GlobalExceptionHandlingMiddleware&gt;();&#10;app.UseMiddleware&lt;RequestResponseLoggingMiddleware&gt;();&#10;app.UseMiddleware&lt;PerformanceMonitoringMiddleware&gt;();&#10;&#10;if (app.Environment.IsDevelopment()) {&#10;&#9;app.UseDeveloperExceptionPage();&#10;}&#10;else {&#10;&#9;app.UseExceptionHandler(&quot;/Error&quot;);&#10;&#9;app.UseHsts();&#10;}&#10;&#10;// Log application startup&#10;Log.Information(&quot;Starting IO.Swagger API application in {Environment} environment&quot;, &#10;    app.Environment.EnvironmentName);&#10;&#10;app.UseHttpsRedirection();&#10;app.UseRouting();&#10;app.UseOutputCache();&#10;app.UseAuthentication();&#10;app.UseTokenExpirationValidation();&#10;app.UseAuthorization();&#10;app.UseSwagger();&#10;app.UseSwaggerUI(c =&gt; {&#10;&#9;c.SwaggerEndpoint(&quot;/swagger/1.0.0/swagger.json&quot;,&quot;JWT Bearer Authentication&quot;);&#10;});&#10;app.MapControllers();&#10;app.MapDefaultEndpoints();&#10;app.Run();&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.IO;&#10;using System.Text;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.OpenApi.Models;&#10;using Microsoft.IdentityModel.Tokens;&#10;using IO.Swagger.Filters;&#10;using IO.Swagger.Middleware;&#10;using IO.Swagger.Services;&#10;using IO.Swagger.Services.Math;&#10;using Microsoft.AspNetCore.Builder;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Serilog;&#10;using Serilog.Events;&#10;using Serilog.Formatting.Compact;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Configure Serilog for robust logging&#10;Log.Logger = new LoggerConfiguration()&#10;    .MinimumLevel.Information()&#10;    .MinimumLevel.Override(&quot;Microsoft&quot;, LogEventLevel.Warning)&#10;    .MinimumLevel.Override(&quot;Microsoft.Hosting.Lifetime&quot;, LogEventLevel.Information)&#10;    .MinimumLevel.Override(&quot;System&quot;, LogEventLevel.Warning)&#10;    .MinimumLevel.Override(&quot;Microsoft.AspNetCore.Authentication&quot;, LogEventLevel.Information)&#10;    .Enrich.FromLogContext()&#10;    .Enrich.WithProperty(&quot;ApplicationName&quot;, &quot;IO.Swagger.API&quot;)&#10;    .Enrich.WithProperty(&quot;Environment&quot;, builder.Environment.EnvironmentName)&#10;    .WriteTo.Console(new CompactJsonFormatter())&#10;    .WriteTo.File(&#10;        new CompactJsonFormatter(),&#10;        &quot;logs/io-swagger-.log&quot;,&#10;        rollingInterval: RollingInterval.Day,&#10;        retainedFileCountLimit: 30,&#10;        fileSizeLimitBytes: 100 * 1024 * 1024, // 100MB&#10;        rollOnFileSizeLimit: true)&#10;    .CreateLogger();&#10;&#10;// Use Serilog as the logging provider&#10;builder.Host.UseSerilog();&#10;&#10;// Register Aspire ServiceDefaults &amp; other services&#10;builder.AddServiceDefaults();&#10;builder.AddRedisClient(connectionName:&quot;redis&quot;);&#10;builder.Services.AddStackExchangeRedisOutputCache(options =&gt; {&#10;&#9;options.Configuration = builder.Configuration[&quot;Connection-Strings:redis&quot;];&#10;});&#10;builder.Services.AddOutputCache();&#10;builder.Services.AddSingleton&lt;IMathService,MathService&gt;();&#10;builder.Services.AddSingleton&lt;ICalculatorBusinessLogicService,CalculatorBusinessLogicService&gt;();&#10;builder.Services.AddSingleton&lt;RedisService&gt;();&#10;builder.Services.AddScoped&lt;IAuthenticationService,AuthenticationService&gt;();&#10;// Add Kafka services&#10;builder.AddKafkaProducer&lt;string,string&gt;(&quot;kafka&quot;);&#10;builder.Services.AddSingleton&lt;IO.Swagger.Services.Kafka.IKafkaProducerService,IO.Swagger.Services.Kafka.KafkaProducerService&gt;();&#10;builder.Services.AddHostedService&lt;IO.Swagger.Services.Kafka.KafkaConsumerService&gt;();&#10;// Add HttpContextAccessor for user context in services&#10;builder.Services.AddHttpContextAccessor();&#10;// Add framework services with System.Text.Json (replace Newtonsoft.Json)&#10;builder.Services.AddControllers()&#10;&#9;   .AddJsonOptions(options =&gt; {&#10;&#9;&#9;   options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;&#9;&#9;   options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));&#10;&#9;&#9;   options.JsonSerializerOptions.WriteIndented = true;&#10;&#9;   })&#10;&#9;   .AddXmlSerializerFormatters();&#10;// Configure JWT Authentication&#10;var jwtSettings = builder.Configuration.GetSection(&quot;Jwt&quot;);&#10;var key = Encoding.UTF8.GetBytes(jwtSettings[&quot;Key&quot;]);&#10;builder.Services.AddAuthentication(options =&gt; {&#10;&#9;&#9;   options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;&#10;&#9;&#9;   options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;&#10;&#9;   })&#10;&#9;   .AddJwtBearer(options =&gt; {&#10;&#9;&#9;   options.RequireHttpsMetadata = false; // Set to true in production&#10;&#9;&#9;   options.SaveToken = true;&#10;&#9;&#9;   options.TokenValidationParameters = new TokenValidationParameters {&#10;&#9;&#9;&#9;   ValidateIssuerSigningKey = true,&#10;&#9;&#9;&#9;   IssuerSigningKey = new SymmetricSecurityKey(key),&#10;&#9;&#9;&#9;   ValidateIssuer = true,&#10;&#9;&#9;&#9;   ValidIssuer = jwtSettings[&quot;Issuer&quot;],&#10;&#9;&#9;&#9;   ValidateAudience = true,&#10;&#9;&#9;&#9;   ValidAudience = jwtSettings[&quot;Audience&quot;],&#10;&#9;&#9;&#9;   ValidateLifetime = true,&#10;&#9;&#9;&#9;   ClockSkew = TimeSpan.Zero&#10;&#9;&#9;   };&#10;&#9;   });&#10;builder.Services.AddAuthorization();&#10;builder.Services.AddSwaggerGen(c =&gt; {&#10;&#9;c.SwaggerDoc(&quot;1.0.0&quot;,&#10;&#9;&#9;&#9;&#9; new OpenApiInfo {&#10;&#9;&#9;&#9;&#9;&#9; Version = &quot;1.0.0&quot;,&#10;&#9;&#9;&#9;&#9;&#9; Title = &quot;Sample JWT Bearer Authentication Project&quot;,&#10;&#9;&#9;&#9;&#9;&#9; Description = &quot;Sample JWT Bearer Authentication Project .NET 9 Web API&quot;,&#10;&#9;&#9;&#9;&#9;&#9; Contact = new OpenApiContact {&#10;&#9;&#9;&#9;&#9;&#9;&#9; Name = &quot;Swagger Codegen Contributors&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9; Url = new Uri(&quot;https://github.com/swagger-api/swagger-codegen&quot;),&#10;&#9;&#9;&#9;&#9;&#9;&#9; Email = &quot;admin@admin.com&quot;&#10;&#9;&#9;&#9;&#9;&#9; },&#10;&#9;&#9;&#9;&#9;&#9; TermsOfService = new Uri(&quot;https://www.example.com/policy&quot;)&#10;&#9;&#9;&#9;&#9; });&#10;&#10;&#9;// Add JWT Authentication to Swagger&#10;&#9;c.AddSecurityDefinition(&quot;Bearer&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;new OpenApiSecurityScheme {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Description = &quot;JWT Authorization header using the Bearer scheme. Example: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Name = &quot;Authorization&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;In = ParameterLocation.Header,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Type = SecuritySchemeType.ApiKey,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Scheme = &quot;Bearer&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;});&#10;&#9;c.AddSecurityRequirement(new OpenApiSecurityRequirement {&#10;&#9;&#9;{&#10;&#9;&#9;&#9;new OpenApiSecurityScheme {&#10;&#9;&#9;&#9;&#9;Reference = new OpenApiReference {&#10;&#9;&#9;&#9;&#9;&#9;Type = ReferenceType.SecurityScheme,&#10;&#9;&#9;&#9;&#9;&#9;Id = &quot;Bearer&quot;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;[]&#10;&#9;&#9;}&#10;&#9;});&#10;&#9;c.CustomSchemaIds(type =&gt; type.FullName);&#10;&#9;c.IncludeXmlComments($&quot;{AppContext.BaseDirectory}{Path.DirectorySeparatorChar}{builder.Environment.ApplicationName}.xml&quot;);&#10;&#9;c.OperationFilter&lt;GeneratePathParamsValidationFilter&gt;();&#10;});&#10;var app = builder.Build();&#10;&#10;// Add comprehensive logging middleware pipeline&#10;app.UseMiddleware&lt;GlobalExceptionHandlingMiddleware&gt;();&#10;app.UseMiddleware&lt;RequestResponseLoggingMiddleware&gt;();&#10;app.UseMiddleware&lt;PerformanceMonitoringMiddleware&gt;();&#10;&#10;if (app.Environment.IsDevelopment()) {&#10;&#9;app.UseDeveloperExceptionPage();&#10;}&#10;else {&#10;&#9;app.UseExceptionHandler(&quot;/Error&quot;);&#10;&#9;app.UseHsts();&#10;}&#10;&#10;// Log application startup&#10;Log.Information(&quot;Starting IO.Swagger API application in {Environment} environment&quot;, &#10;    app.Environment.EnvironmentName);&#10;&#10;app.UseHttpsRedirection();&#10;app.UseRouting();&#10;app.UseOutputCache();&#10;app.UseAuthentication();&#10;app.UseTokenExpirationValidation();&#10;app.UseAuthorization();&#10;app.UseSwagger();&#10;app.UseSwaggerUI(c =&gt; {&#10;&#9;c.SwaggerEndpoint(&quot;/swagger/1.0.0/swagger.json&quot;,&quot;JWT Bearer Authentication&quot;);&#10;});&#10;app.MapControllers();&#10;app.MapDefaultEndpoints();&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Services/CalculatorWorkflowService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Services/CalculatorWorkflowService.cs" />
              <option name="updatedContent" value="using Microsoft.Extensions.Logging;&#10;using IO.Swagger.Models;&#10;using IO.Swagger.Models.Math;&#10;&#10;namespace IO.Swagger.Services&#10;{&#10;    public interface ICalculatorWorkflowService&#10;    {&#10;        Task&lt;MathResponse&gt; ExecuteCalculationWorkflowAsync(MathRequest request, string operationId);&#10;    }&#10;&#10;    public class CalculatorWorkflowService : ICalculatorWorkflowService&#10;    {&#10;        private readonly IMathService _mathService;&#10;        private readonly ILogger&lt;CalculatorWorkflowService&gt; _logger;&#10;&#10;        public CalculatorWorkflowService(IMathService mathService, ILogger&lt;CalculatorWorkflowService&gt; logger)&#10;        {&#10;            _mathService = mathService;&#10;            _logger = logger;&#10;        }&#10;&#10;        public async Task&lt;MathResponse&gt; ExecuteCalculationWorkflowAsync(MathRequest request, string operationId)&#10;        {&#10;            _logger.LogInformation(&quot;Starting calculation workflow for operation ID: {OperationId}&quot;, operationId);&#10;&#10;            try&#10;            {&#10;                // Validate input&#10;                if (request == null)&#10;                {&#10;                    _logger.LogWarning(&quot;Null request received for operation ID: {OperationId}&quot;, operationId);&#10;                    return new MathResponse&#10;                    {&#10;                        Success = false,&#10;                        Error = &quot;Request cannot be null&quot;&#10;                    };&#10;                }&#10;&#10;                if (!request.X.HasValue || !request.Y.HasValue)&#10;                {&#10;                    _logger.LogWarning(&quot;Invalid operands received for operation ID: {OperationId}. X: {X}, Y: {Y}&quot;, &#10;                        operationId, request.X, request.Y);&#10;                    return new MathResponse&#10;                    {&#10;                        Success = false,&#10;                        Error = &quot;Both X and Y operands are required&quot;&#10;                    };&#10;                }&#10;&#10;                if (!request.Operation.HasValue)&#10;                {&#10;                    _logger.LogWarning(&quot;No operation specified for operation ID: {OperationId}&quot;, operationId);&#10;                    return new MathResponse&#10;                    {&#10;                        Success = false,&#10;                        Error = &quot;Operation type is required&quot;&#10;                    };&#10;                }&#10;&#10;                _logger.LogDebug(&quot;Input validation passed for operation ID: {OperationId}&quot;, operationId);&#10;&#10;                // Delegate to MathService for calculation&#10;                var result = await _mathService.PerformCalculationAsync(request, operationId);&#10;&#10;                _logger.LogInformation(&quot;Calculation workflow completed for operation ID: {OperationId}, Success: {Success}&quot;, &#10;                    operationId, result.Success);&#10;&#10;                return result;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                _logger.LogError(ex, &quot;Error in calculation workflow for operation ID: {OperationId}&quot;, operationId);&#10;                return new MathResponse&#10;                {&#10;                    Success = false,&#10;                    Error = $&quot;Workflow error: {ex.Message}&quot;&#10;                };&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Services/Kafka/KafkaConsumerService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Services/Kafka/KafkaConsumerService.cs" />
              <option name="updatedContent" value="using Confluent.Kafka;&#10;using IO.Swagger.Models.Kafka;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Services.Kafka;&#10;&#10;public class KafkaConsumerService : BackgroundService&#10;{&#10;    private readonly IConsumer&lt;string, string&gt; _consumer;&#10;    private readonly ILogger&lt;KafkaConsumerService&gt; _logger;&#10;    private readonly IServiceProvider _serviceProvider;&#10;    private readonly string[] _topics;&#10;&#10;    public KafkaConsumerService(IConfiguration configuration, ILogger&lt;KafkaConsumerService&gt; logger, IServiceProvider serviceProvider)&#10;    {&#10;        _logger = logger;&#10;        _serviceProvider = serviceProvider;&#10;        &#10;        var calculationStartedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationStarted&quot;) ?? &quot;calculation-started&quot;;&#10;        var calculationCompletedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationCompleted&quot;) ?? &quot;calculation-completed&quot;;&#10;        _topics = new[] { calculationStartedTopic, calculationCompletedTopic };&#10;&#10;        var config = new ConsumerConfig&#10;        {&#10;            BootstrapServers = configuration.GetConnectionString(&quot;kafka&quot;) ?? &quot;localhost:9092&quot;,&#10;            GroupId = &quot;io-swagger-consumer-group&quot;,&#10;            ClientId = &quot;io-swagger-consumer&quot;,&#10;            AutoOffsetReset = AutoOffsetReset.Earliest,&#10;            EnableAutoCommit = false,&#10;            EnableAutoOffsetStore = false,&#10;            SessionTimeoutMs = 30000,&#10;            HeartbeatIntervalMs = 10000,&#10;            MaxPollIntervalMs = 300000,&#10;            FetchMinBytes = 1,&#10;            FetchMaxWaitMs = 500&#10;        };&#10;&#10;        _consumer = new ConsumerBuilder&lt;string, string&gt;(config)&#10;            .SetErrorHandler((_, e) =&gt; _logger.LogError(&quot;Kafka consumer error: {Error}&quot;, e))&#10;            .SetLogHandler((_, log) =&gt; &#10;            {&#10;                if (log.Level &lt;= SyslogLevel.Warning)&#10;                    _logger.LogWarning(&quot;Kafka consumer log: {Message}&quot;, log.Message);&#10;            })&#10;            .SetPartitionsAssignedHandler((c, partitions) =&gt;&#10;            {&#10;                _logger.LogInformation(&quot;Kafka consumer assigned partitions: {Partitions}&quot;, &#10;                    string.Join(&quot;, &quot;, partitions.Select(p =&gt; $&quot;{p.Topic}[{p.Partition}]&quot;)));&#10;            })&#10;            .SetPartitionsRevokedHandler((c, partitions) =&gt;&#10;            {&#10;                _logger.LogInformation(&quot;Kafka consumer revoked partitions: {Partitions}&quot;, &#10;                    string.Join(&quot;, &quot;, partitions.Select(p =&gt; $&quot;{p.Topic}[{p.Partition}]&quot;)));&#10;            })&#10;            .Build();&#10;    }&#10;&#10;    protected override async Task ExecuteAsync(CancellationToken stoppingToken)&#10;    {&#10;        try&#10;        {&#10;            _consumer.Subscribe(_topics);&#10;            _logger.LogInformation(&quot;Kafka consumer started. Subscribed to topics: {Topics}&quot;, string.Join(&quot;, &quot;, _topics));&#10;&#10;            while (!stoppingToken.IsCancellationRequested)&#10;            {&#10;                try&#10;                {&#10;                    var consumeResult = _consumer.Consume(stoppingToken);&#10;                    &#10;                    if (consumeResult?.Message != null)&#10;                    {&#10;                        await ProcessMessageAsync(consumeResult, stoppingToken);&#10;                        _consumer.Commit(consumeResult);&#10;                        _consumer.StoreOffset(consumeResult);&#10;                    }&#10;                }&#10;                catch (ConsumeException ex)&#10;                {&#10;                    _logger.LogError(ex, &quot;Kafka consume error: {Error}&quot;, ex.Error.Reason);&#10;                }&#10;                catch (OperationCanceledException)&#10;                {&#10;                    // Expected when cancellation is requested&#10;                    break;&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    _logger.LogError(ex, &quot;Unexpected error in Kafka consumer&quot;);&#10;                    // Don't break the loop for unexpected errors, just log and continue&#10;                    await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogCritical(ex, &quot;Fatal error in Kafka consumer service&quot;);&#10;        }&#10;        finally&#10;        {&#10;            try&#10;            {&#10;                _consumer?.Close();&#10;                _consumer?.Dispose();&#10;                _logger.LogInformation(&quot;Kafka consumer service stopped&quot;);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                _logger.LogError(ex, &quot;Error disposing Kafka consumer&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    private async Task ProcessMessageAsync(ConsumeResult&lt;string, string&gt; result, CancellationToken cancellationToken)&#10;    {&#10;        try&#10;        {&#10;            var eventType = GetEventTypeFromHeaders(result.Message.Headers);&#10;            _logger.LogDebug(&quot;Processing Kafka message. Topic: {Topic}, Key: {Key}, EventType: {EventType}&quot;, &#10;                result.Topic, result.Message.Key, eventType);&#10;&#10;            switch (eventType)&#10;            {&#10;                case &quot;CalculationStarted&quot;:&#10;                    await ProcessCalculationStartedEvent(result.Message.Value, cancellationToken);&#10;                    break;&#10;                case &quot;CalculationCompleted&quot;:&#10;                    await ProcessCalculationCompletedEvent(result.Message.Value, cancellationToken);&#10;                    break;&#10;                default:&#10;                    _logger.LogWarning(&quot;Unknown event type: {EventType} for message key: {Key}&quot;, eventType, result.Message.Key);&#10;                    break;&#10;            }&#10;&#10;            _logger.LogDebug(&quot;Successfully processed Kafka message. Topic: {Topic}, Key: {Key}, Offset: {Offset}&quot;, &#10;                result.Topic, result.Message.Key, result.Offset);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Error processing Kafka message. Topic: {Topic}, Key: {Key}, Offset: {Offset}&quot;, &#10;                result.Topic, result.Message?.Key, result.Offset);&#10;            throw; // Re-throw to prevent commit&#10;        }&#10;    }&#10;&#10;    private async Task ProcessCalculationStartedEvent(string messageValue, CancellationToken cancellationToken)&#10;    {&#10;        try&#10;        {&#10;            var calculationEvent = JsonSerializer.Deserialize&lt;CalculationStartedEvent&gt;(messageValue);&#10;            if (calculationEvent == null) return;&#10;&#10;            using var scope = _serviceProvider.CreateScope();&#10;            var logger = scope.ServiceProvider.GetRequiredService&lt;ILogger&lt;KafkaConsumerService&gt;&gt;();&#10;            &#10;            logger.LogInformation(&quot;Processing calculation started event for operation {OperationId}: {Operation}({X}, {Y})&quot;, &#10;                calculationEvent.OperationId, calculationEvent.Operation, calculationEvent.X, calculationEvent.Y);&#10;&#10;            // Here you could add business logic like:&#10;            // - Updating operation status in database&#10;            // - Sending notifications&#10;            // - Triggering other workflows&#10;            // - Metrics collection&#10;&#10;            await Task.CompletedTask; // Placeholder for actual processing&#10;        }&#10;        catch (JsonException ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to deserialize CalculationStartedEvent: {MessageValue}&quot;, messageValue);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    private async Task ProcessCalculationCompletedEvent(string messageValue, CancellationToken cancellationToken)&#10;    {&#10;        try&#10;        {&#10;            var calculationEvent = JsonSerializer.Deserialize&lt;CalculationCompletedEvent&gt;(messageValue);&#10;            if (calculationEvent == null) return;&#10;&#10;            using var scope = _serviceProvider.CreateScope();&#10;            var logger = scope.ServiceProvider.GetRequiredService&lt;ILogger&lt;KafkaConsumerService&gt;&gt;();&#10;            &#10;            logger.LogInformation(&quot;Processing calculation completed event for operation {OperationId}: Success={Success}, Result={Result}, ExecutionTime={ExecutionTime}ms, CacheHit={CacheHit}&quot;, &#10;                calculationEvent.OperationId, calculationEvent.Success, calculationEvent.Result, calculationEvent.ExecutionTimeMs, calculationEvent.CacheHit);&#10;&#10;            // Here you could add business logic like:&#10;            // - Updating final operation status in database&#10;            // - Sending completion notifications&#10;            // - Updating analytics/metrics&#10;            // - Triggering downstream processes&#10;            // - Audit logging&#10;&#10;            await Task.CompletedTask; // Placeholder for actual processing&#10;        }&#10;        catch (JsonException ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to deserialize CalculationCompletedEvent: {MessageValue}&quot;, messageValue);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    private static string GetEventTypeFromHeaders(Headers? headers)&#10;    {&#10;        if (headers == null) return &quot;Unknown&quot;;&#10;        &#10;        var eventTypeHeader = headers.FirstOrDefault(h =&gt; h.Key == &quot;eventType&quot;);&#10;        return eventTypeHeader != null &#10;            ? System.Text.Encoding.UTF8.GetString(eventTypeHeader.GetValueBytes()) &#10;            : &quot;Unknown&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Services/Kafka/KafkaProducerService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Services/Kafka/KafkaProducerService.cs" />
              <option name="updatedContent" value="using Confluent.Kafka;&#10;using IO.Swagger.Models.Kafka;&#10;using System.Text.Json;&#10;&#10;namespace IO.Swagger.Services.Kafka;&#10;&#10;public interface IKafkaProducerService&#10;{&#10;    Task SendCalculationStartedAsync(CalculationStartedEvent calculationEvent);&#10;    Task SendCalculationCompletedAsync(CalculationCompletedEvent calculationEvent);&#10;}&#10;&#10;public class KafkaProducerService : IKafkaProducerService, IDisposable&#10;{&#10;    private readonly IProducer&lt;string, string&gt; _producer;&#10;    private readonly ILogger&lt;KafkaProducerService&gt; _logger;&#10;    private readonly string _calculationStartedTopic;&#10;    private readonly string _calculationCompletedTopic;&#10;&#10;    public KafkaProducerService(IConfiguration configuration, ILogger&lt;KafkaProducerService&gt; logger)&#10;    {&#10;        _logger = logger;&#10;        _calculationStartedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationStarted&quot;) ?? &quot;calculation-started&quot;;&#10;        _calculationCompletedTopic = configuration.GetValue&lt;string&gt;(&quot;Kafka:Topics:CalculationCompleted&quot;) ?? &quot;calculation-completed&quot;;&#10;&#10;        var config = new ProducerConfig&#10;        {&#10;            BootstrapServers = configuration.GetConnectionString(&quot;kafka&quot;) ?? &quot;localhost:9092&quot;,&#10;            ClientId = &quot;io-swagger-producer&quot;,&#10;            Acks = Acks.Leader,&#10;            EnableIdempotence = true,&#10;            MessageTimeoutMs = 30000,&#10;            RequestTimeoutMs = 30000,&#10;            DeliveryReportFields = &quot;all&quot;,&#10;            CompressionType = CompressionType.Snappy&#10;        };&#10;&#10;        _producer = new ProducerBuilder&lt;string, string&gt;(config)&#10;            .SetErrorHandler((_, e) =&gt; _logger.LogError(&quot;Kafka producer error: {Error}&quot;, e))&#10;            .SetLogHandler((_, log) =&gt; &#10;            {&#10;                if (log.Level &lt;= SyslogLevel.Warning)&#10;                    _logger.LogWarning(&quot;Kafka log: {Message}&quot;, log.Message);&#10;            })&#10;            .Build();&#10;    }&#10;&#10;    public async Task SendCalculationStartedAsync(CalculationStartedEvent calculationEvent)&#10;    {&#10;        try&#10;        {&#10;            var json = JsonSerializer.Serialize(calculationEvent);&#10;            var message = new Message&lt;string, string&gt;&#10;            {&#10;                Key = calculationEvent.OperationId,&#10;                Value = json,&#10;                Headers = new Headers&#10;                {&#10;                    { &quot;eventType&quot;, System.Text.Encoding.UTF8.GetBytes(&quot;CalculationStarted&quot;) },&#10;                    { &quot;timestamp&quot;, System.Text.Encoding.UTF8.GetBytes(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString()) }&#10;                }&#10;            };&#10;&#10;            var result = await _producer.ProduceAsync(_calculationStartedTopic, message);&#10;            _logger.LogInformation(&quot;Calculation started event sent to Kafka. Topic: {Topic}, Partition: {Partition}, Offset: {Offset}, OperationId: {OperationId}&quot;,&#10;                result.Topic, result.Partition.Value, result.Offset.Value, calculationEvent.OperationId);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to send calculation started event to Kafka for operation {OperationId}&quot;, calculationEvent.OperationId);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public async Task SendCalculationCompletedAsync(CalculationCompletedEvent calculationEvent)&#10;    {&#10;        try&#10;        {&#10;            var json = JsonSerializer.Serialize(calculationEvent);&#10;            var message = new Message&lt;string, string&gt;&#10;            {&#10;                Key = calculationEvent.OperationId,&#10;                Value = json,&#10;                Headers = new Headers&#10;                {&#10;                    { &quot;eventType&quot;, System.Text.Encoding.UTF8.GetBytes(&quot;CalculationCompleted&quot;) },&#10;                    { &quot;timestamp&quot;, System.Text.Encoding.UTF8.GetBytes(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds().ToString()) }&#10;                }&#10;            };&#10;&#10;            var result = await _producer.ProduceAsync(_calculationCompletedTopic, message);&#10;            _logger.LogInformation(&quot;Calculation completed event sent to Kafka. Topic: {Topic}, Partition: {Partition}, Offset: {Offset}, OperationId: {OperationId}, Success: {Success}&quot;,&#10;                result.Topic, result.Partition.Value, result.Offset.Value, calculationEvent.OperationId, calculationEvent.Success);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Failed to send calculation completed event to Kafka for operation {OperationId}&quot;, calculationEvent.OperationId);&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public void Dispose()&#10;    {&#10;        _producer?.Flush();&#10;        _producer?.Dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Services/MathService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Services/MathService.cs" />
              <option name="updatedContent" value="using Microsoft.Extensions.Logging;&#10;using IO.Swagger.Models;&#10;using IO.Swagger.Models.Math;&#10;&#10;namespace IO.Swagger.Services&#10;{&#10;    public interface IMathService&#10;    {&#10;        Task&lt;MathResponse&gt; PerformCalculationAsync(MathRequest request, string operationId);&#10;    }&#10;&#10;    public class MathService : IMathService&#10;    {&#10;        private readonly ILogger&lt;MathService&gt; _logger;&#10;&#10;        public MathService(ILogger&lt;MathService&gt; logger)&#10;        {&#10;            _logger = logger;&#10;        }&#10;&#10;        public async Task&lt;MathResponse&gt; PerformCalculationAsync(MathRequest request, string operationId)&#10;        {&#10;            _logger.LogInformation(&quot;Starting math calculation for operation ID: {OperationId}, Operation: {Operation}, X: {X}, Y: {Y}&quot;, &#10;                operationId, request.Operation, request.X, request.Y);&#10;&#10;            try&#10;            {&#10;                decimal result = 0;&#10;&#10;                // Perform the mathematical operation&#10;                switch (request.Operation)&#10;                {&#10;                    case MathOperationType.AddEnum:&#10;                        result = request.X.Value + request.Y.Value;&#10;                        _logger.LogDebug(&quot;Addition operation: {X} + {Y} = {Result}&quot;, request.X, request.Y, result);&#10;                        break;&#10;                    case MathOperationType.SubtractEnum:&#10;                        result = request.X.Value - request.Y.Value;&#10;                        _logger.LogDebug(&quot;Subtraction operation: {X} - {Y} = {Result}&quot;, request.X, request.Y, result);&#10;                        break;&#10;                    case MathOperationType.MultiplyEnum:&#10;                        result = request.X.Value * request.Y.Value;&#10;                        _logger.LogDebug(&quot;Multiplication operation: {X} * {Y} = {Result}&quot;, request.X, request.Y, result);&#10;                        break;&#10;                    case MathOperationType.DivideEnum:&#10;                        if (request.Y.Value == 0)&#10;                        {&#10;                            _logger.LogWarning(&quot;Division by zero attempted for operation ID: {OperationId}&quot;, operationId);&#10;                            return new MathResponse&#10;                            {&#10;                                Success = false,&#10;                                Error = &quot;Division by zero is not allowed&quot;&#10;                            };&#10;                        }&#10;                        result = request.X.Value / request.Y.Value;&#10;                        _logger.LogDebug(&quot;Division operation: {X} / {Y} = {Result}&quot;, request.X, request.Y, result);&#10;                        break;&#10;                    default:&#10;                        _logger.LogWarning(&quot;Invalid operation type: {Operation} for operation ID: {OperationId}&quot;, request.Operation, operationId);&#10;                        return new MathResponse&#10;                        {&#10;                            Success = false,&#10;                            Error = &quot;Invalid operation&quot;&#10;                        };&#10;                }&#10;&#10;                var response = new MathResponse&#10;                {&#10;                    Success = true,&#10;                    Result = result&#10;                };&#10;&#10;                _logger.LogInformation(&quot;Math calculation completed successfully for operation ID: {OperationId}, Result: {Result}&quot;, &#10;                    operationId, result);&#10;&#10;                return response;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                _logger.LogError(ex, &quot;Error performing calculation for operation ID: {OperationId}&quot;, operationId);&#10;                return new MathResponse&#10;                {&#10;                    Success = false,&#10;                    Error = $&quot;Error performing calculation: {ex.Message}&quot;&#10;                };&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/IO.Swagger/Startup.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/IO.Swagger/Startup.cs" />
              <option name="originalContent" value="/*&#10; * Sample Access Code Flow OAuth2 Project&#10; *&#10; * This is an example of using OAuth2 Access Code Flow in a specification to describe security to your API.&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; * &#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;&#10;using System;&#10;using System.IO;&#10;using System.Text;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.AspNetCore.Builder;&#10;using Microsoft.AspNetCore.Hosting;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Microsoft.Extensions.Logging;&#10;using Microsoft.OpenApi.Models;&#10;using Microsoft.IdentityModel.Tokens;&#10;using Swashbuckle.AspNetCore.Swagger;&#10;using Swashbuckle.AspNetCore.SwaggerGen;&#10;using IO.Swagger.Filters;&#10;&#10;namespace IO.Swagger&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Startup&#10;    /// &lt;/summary&gt;&#10;    public class Startup&#10;    {&#10;        private readonly IWebHostEnvironment _hostingEnv;&#10;&#10;        private IConfiguration Configuration { get; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Constructor&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;env&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;configuration&quot;&gt;&lt;/param&gt;&#10;        public Startup(IWebHostEnvironment env, IConfiguration configuration)&#10;        {&#10;            _hostingEnv = env;&#10;            Configuration = configuration;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// This method gets called by the runtime. Use this method to add services to the container.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;services&quot;&gt;&lt;/param&gt;&#10;        public void ConfigureServices(IServiceCollection services)&#10;        {&#10;            // Add Aspire service defaults&#10;            services.AddServiceDefaults();&#10;&#10;            // Add Redis&#10;            services.AddRedis(&quot;redis&quot;);&#10;&#10;            // Add Kafka&#10;            services.AddKafka(&quot;kafka&quot;);&#10;&#10;            // Add framework services with System.Text.Json&#10;            services&#10;                .AddControllers()&#10;                .AddJsonOptions(options =&gt;&#10;                {&#10;                    options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;                    options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));&#10;                    options.JsonSerializerOptions.WriteIndented = true;&#10;                })&#10;                .AddXmlSerializerFormatters();&#10;&#10;            // Configure JWT Authentication&#10;            var jwtSettings = Configuration.GetSection(&quot;Jwt&quot;);&#10;            var key = Encoding.UTF8.GetBytes(jwtSettings[&quot;Key&quot;]);&#10;&#10;            services.AddAuthentication(options =&gt;&#10;            {&#10;                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;&#10;                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;&#10;            })&#10;            .AddJwtBearer(options =&gt;&#10;            {&#10;                options.RequireHttpsMetadata = false; // Set to true in production&#10;                options.SaveToken = true;&#10;                options.TokenValidationParameters = new TokenValidationParameters&#10;                {&#10;                    ValidateIssuerSigningKey = true,&#10;                    IssuerSigningKey = new SymmetricSecurityKey(key),&#10;                    ValidateIssuer = true,&#10;                    ValidIssuer = jwtSettings[&quot;Issuer&quot;],&#10;                    ValidateAudience = true,&#10;                    ValidAudience = jwtSettings[&quot;Audience&quot;],&#10;                    ValidateLifetime = true,&#10;                    ClockSkew = TimeSpan.Zero&#10;                };&#10;            });&#10;&#10;            services.AddAuthorization();&#10;&#10;            services&#10;                .AddSwaggerGen(c =&gt;&#10;                {&#10;                    c.SwaggerDoc(&quot;1.0.0&quot;, new OpenApiInfo&#10;                    {&#10;                        Version = &quot;1.0.0&quot;,&#10;                        Title = &quot;Sample Access Code Flow OAuth2 Project&quot;,&#10;                        Description = &quot;Sample Access Code Flow OAuth2 Project .NET 9 Web API&quot;,&#10;                        Contact = new OpenApiContact()&#10;                        {&#10;                           Name = &quot;Swagger Codegen Contributors&quot;,&#10;                           Url = new Uri(&quot;https://github.com/swagger-api/swagger-codegen&quot;),&#10;                           Email = &quot;admin@admin.com&quot;&#10;                        },&#10;                        TermsOfService = new Uri(&quot;https://www.example.com/policy&quot;)&#10;                    });&#10;&#10;                    // Add JWT Authentication to Swagger&#10;                    c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme&#10;                    {&#10;                        Description = &quot;JWT Authorization header using the Bearer scheme. Example: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;                        Name = &quot;Authorization&quot;,&#10;                        In = ParameterLocation.Header,&#10;                        Type = SecuritySchemeType.ApiKey,&#10;                        Scheme = &quot;Bearer&quot;&#10;                    });&#10;&#10;                    c.AddSecurityRequirement(new OpenApiSecurityRequirement&#10;                    {&#10;                        {&#10;                            new OpenApiSecurityScheme&#10;                            {&#10;                                Reference = new OpenApiReference&#10;                                {&#10;                                    Type = ReferenceType.SecurityScheme,&#10;                                    Id = &quot;Bearer&quot;&#10;                                }&#10;                            },&#10;                            new string[] {}&#10;                        }&#10;                    });&#10;&#10;                    c.CustomSchemaIds(type =&gt; type.FullName);&#10;                    c.IncludeXmlComments($&quot;{AppContext.BaseDirectory}{Path.DirectorySeparatorChar}{_hostingEnv.ApplicationName}.xml&quot;);&#10;&#10;                    // Include DataAnnotation attributes on Controller Action parameters as Swagger validation rules (e.g required, pattern, ..)&#10;                    // Use [ValidateModelState] on Actions to actually validate it in C# as well!&#10;                    c.OperationFilter&lt;GeneratePathParamsValidationFilter&gt;();&#10;                });&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;app&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;env&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;loggerFactory&quot;&gt;&lt;/param&gt;&#10;        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)&#10;        {&#10;            // Add Aspire default middleware&#10;            app.MapDefaultEndpoints();&#10;&#10;            if (env.IsDevelopment())&#10;            {&#10;                app.UseDeveloperExceptionPage();&#10;            }&#10;            else&#10;            {&#10;                //TODO: Enable production exception handling (https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling)&#10;                app.UseExceptionHandler(&quot;/Error&quot;);&#10;                app.UseHsts();&#10;            }&#10;&#10;            //TODO: Use Https Redirection&#10;            // app.UseHttpsRedirection();&#10;&#10;            app.UseRouting();&#10;&#10;            // Authentication must come after UseRouting() but before UseAuthorization()&#10;            app.UseAuthentication();&#10;            app.UseAuthorization();&#10;&#10;            app.UseSwagger();&#10;            app.UseSwaggerUI(c =&gt;&#10;            {&#10;                //TODO: Either use the SwaggerGen generated Swagger contract (generated from C# classes)&#10;                c.SwaggerEndpoint(&quot;/swagger/1.0.0/swagger.json&quot;, &quot;Sample Access Code Flow OAuth2 Project&quot;);&#10;&#10;                //TODO: Or alternatively use the original Swagger contract that's included in the static files&#10;                // c.SwaggerEndpoint(&quot;/swagger-original.json&quot;, &quot;Sample Access Code Flow OAuth2 Project Original&quot;);&#10;            });&#10;&#10;            //TODO: Uncomment this if you need wwwroot folder&#10;            // app.UseStaticFiles();&#10;&#10;            app.UseEndpoints(endpoints =&gt;&#10;            {&#10;                endpoints.MapControllers();&#10;            });&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Sample Access Code Flow OAuth2 Project&#10; *&#10; * This is an example of using OAuth2 Access Code Flow in a specification to describe security to your API.&#10; *&#10; * OpenAPI spec version: 1.0.0&#10; * &#10; * Generated by: https://github.com/swagger-api/swagger-codegen.git&#10; */&#10;&#10;using System;&#10;using System.IO;&#10;using System.Text;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.AspNetCore.Builder;&#10;using Microsoft.AspNetCore.Hosting;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Microsoft.Extensions.Logging;&#10;using Microsoft.OpenApi.Models;&#10;using Microsoft.IdentityModel.Tokens;&#10;using Swashbuckle.AspNetCore.Swagger;&#10;using Swashbuckle.AspNetCore.SwaggerGen;&#10;using IO.Swagger.Filters;&#10;&#10;namespace IO.Swagger&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Startup&#10;    /// &lt;/summary&gt;&#10;    public class Startup&#10;    {&#10;        private readonly IWebHostEnvironment _hostingEnv;&#10;&#10;        private IConfiguration Configuration { get; }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Constructor&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;env&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;configuration&quot;&gt;&lt;/param&gt;&#10;        public Startup(IWebHostEnvironment env, IConfiguration configuration)&#10;        {&#10;            _hostingEnv = env;&#10;            Configuration = configuration;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// This method gets called by the runtime. Use this method to add services to the container.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;services&quot;&gt;&lt;/param&gt;&#10;        public void ConfigureServices(IServiceCollection services)&#10;        {&#10;            // Add Aspire service defaults&#10;            services.AddServiceDefaults();&#10;&#10;            // Add Redis&#10;            services.AddRedis(&quot;redis&quot;);&#10;&#10;            // Add Kafka&#10;            services.AddKafka(&quot;kafka&quot;);&#10;&#10;            // Add framework services with System.Text.Json&#10;            services&#10;                .AddControllers()&#10;                .AddJsonOptions(options =&gt;&#10;                {&#10;                    options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;&#10;                    options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));&#10;                    options.JsonSerializerOptions.WriteIndented = true;&#10;                })&#10;                .AddXmlSerializerFormatters();&#10;&#10;            // Configure JWT Authentication&#10;            var jwtSettings = Configuration.GetSection(&quot;Jwt&quot;);&#10;            var key = Encoding.UTF8.GetBytes(jwtSettings[&quot;Key&quot;]);&#10;&#10;            services.AddAuthentication(options =&gt;&#10;            {&#10;                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;&#10;                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;&#10;            })&#10;            .AddJwtBearer(options =&gt;&#10;            {&#10;                options.RequireHttpsMetadata = false; // Set to true in production&#10;                options.SaveToken = true;&#10;                options.TokenValidationParameters = new TokenValidationParameters&#10;                {&#10;                    ValidateIssuerSigningKey = true,&#10;                    IssuerSigningKey = new SymmetricSecurityKey(key),&#10;                    ValidateIssuer = true,&#10;                    ValidIssuer = jwtSettings[&quot;Issuer&quot;],&#10;                    ValidateAudience = true,&#10;                    ValidAudience = jwtSettings[&quot;Audience&quot;],&#10;                    ValidateLifetime = true,&#10;                    ClockSkew = TimeSpan.Zero&#10;                };&#10;            });&#10;&#10;            services.AddAuthorization();&#10;&#10;            services&#10;                .AddSwaggerGen(c =&gt;&#10;                {&#10;                    c.SwaggerDoc(&quot;1.0.0&quot;, new OpenApiInfo&#10;                    {&#10;                        Version = &quot;1.0.0&quot;,&#10;                        Title = &quot;Sample Access Code Flow OAuth2 Project&quot;,&#10;                        Description = &quot;Sample Access Code Flow OAuth2 Project .NET 9 Web API&quot;,&#10;                        Contact = new OpenApiContact()&#10;                        {&#10;                           Name = &quot;Swagger Codegen Contributors&quot;,&#10;                           Url = new Uri(&quot;https://github.com/swagger-api/swagger-codegen&quot;),&#10;                           Email = &quot;admin@admin.com&quot;&#10;                        },&#10;                        TermsOfService = new Uri(&quot;https://www.example.com/policy&quot;)&#10;                    });&#10;&#10;                    // Add JWT Authentication to Swagger&#10;                    c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme&#10;                    {&#10;                        Description = &quot;JWT Authorization header using the Bearer scheme. Example: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;                        Name = &quot;Authorization&quot;,&#10;                        In = ParameterLocation.Header,&#10;                        Type = SecuritySchemeType.ApiKey,&#10;                        Scheme = &quot;Bearer&quot;&#10;                    });&#10;&#10;                    c.AddSecurityRequirement(new OpenApiSecurityRequirement&#10;                    {&#10;                        {&#10;                            new OpenApiSecurityScheme&#10;                            {&#10;                                Reference = new OpenApiReference&#10;                                {&#10;                                    Type = ReferenceType.SecurityScheme,&#10;                                    Id = &quot;Bearer&quot;&#10;                                }&#10;                            },&#10;                            new string[] {}&#10;                        }&#10;                    });&#10;&#10;                    c.CustomSchemaIds(type =&gt; type.FullName);&#10;                    c.IncludeXmlComments($&quot;{AppContext.BaseDirectory}{Path.DirectorySeparatorChar}{_hostingEnv.ApplicationName}.xml&quot;);&#10;&#10;                    // Include DataAnnotation attributes on Controller Action parameters as Swagger validation rules (e.g required, pattern, ..)&#10;                    // Use [ValidateModelState] on Actions to actually validate it in C# as well!&#10;                    c.OperationFilter&lt;GeneratePathParamsValidationFilter&gt;();&#10;                });&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;app&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;env&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;loggerFactory&quot;&gt;&lt;/param&gt;&#10;        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)&#10;        {&#10;            if (env.IsDevelopment())&#10;            {&#10;                app.UseDeveloperExceptionPage();&#10;            }&#10;            else&#10;            {&#10;                //TODO: Enable production exception handling (https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling)&#10;                app.UseExceptionHandler(&quot;/Error&quot;);&#10;                app.UseHsts();&#10;            }&#10;&#10;            //TODO: Use Https Redirection&#10;            // app.UseHttpsRedirection();&#10;&#10;            app.UseRouting();&#10;&#10;            // Authentication must come after UseRouting() but before UseAuthorization()&#10;            app.UseAuthentication();&#10;            app.UseAuthorization();&#10;&#10;            app.UseSwagger();&#10;            app.UseSwaggerUI(c =&gt;&#10;            {&#10;                //TODO: Either use the SwaggerGen generated Swagger contract (generated from C# classes)&#10;                c.SwaggerEndpoint(&quot;/swagger/1.0.0/swagger.json&quot;, &quot;Sample Access Code Flow OAuth2 Project&quot;);&#10;&#10;                //TODO: Or alternatively use the original Swagger contract that's included in the static files&#10;                // c.SwaggerEndpoint(&quot;/swagger-original.json&quot;, &quot;Sample Access Code Flow OAuth2 Project Original&quot;);&#10;            });&#10;&#10;            //TODO: Uncomment this if you need wwwroot folder&#10;            // app.UseStaticFiles();&#10;&#10;            app.UseEndpoints(endpoints =&gt;&#10;            {&#10;                endpoints.MapControllers();&#10;                // Add Aspire default endpoints&#10;                endpoints.MapDefaultEndpoints();&#10;            });&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>